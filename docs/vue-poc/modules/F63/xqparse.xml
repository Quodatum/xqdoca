<XQuery>(:~ 
 :  pipeline library 
 : @author Andy Bunce
 : @version 0.2
 : @date nov 2017 jun 2018
:)
<LibraryModule><ModuleDecl><TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN>  <NCName>qipe</NCName><TOKEN>=</TOKEN><StringLiteral>'http://quodatum.com/ns/pipeline'</StringLiteral><TOKEN>;</TOKEN></ModuleDecl>
<Prolog><ModuleImport><TOKEN>import</TOKEN> <TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>schematron</NCName> <TOKEN>=</TOKEN> <StringLiteral>"http://github.com/Schematron/schematron-basex"</StringLiteral></ModuleImport><TOKEN>;</TOKEN>
<ModuleImport><TOKEN>import</TOKEN> <TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>fw</NCName><TOKEN>=</TOKEN><StringLiteral>"quodatum:file.walker"</StringLiteral></ModuleImport><TOKEN>;</TOKEN>

<NamespaceDecl><TOKEN>declare</TOKEN> <TOKEN>namespace</TOKEN> <NCName>c</NCName><TOKEN>=</TOKEN><StringLiteral>"http://www.w3.org/ns/xproc-step"</StringLiteral></NamespaceDecl><TOKEN>;</TOKEN>
<AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>qipe:outputs</QName><TOKEN>:=</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN>
                            <MapConstructorEntry><StringLiteral>"html5"</StringLiteral><TOKEN>:</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"method"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"html"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN><MapConstructorEntry><StringLiteral>"version"</StringLiteral><TOKEN>:</TOKEN><StringLiteral>"5.0"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></MapConstructorEntry><TOKEN>,</TOKEN>
                            <MapConstructorEntry><StringLiteral>"xml"</StringLiteral><TOKEN>:</TOKEN>  <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"indent"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"no"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></MapConstructorEntry>
                            <TOKEN>}</TOKEN></MapConstructor></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>
(:~  run a pipeline 
 : @param $pipe the pipeline document
 : @param $initial starting data as sequence
 : @result 
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:run</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>pipe</QName> <TypeDeclaration><TOKEN>as</TOKEN> <AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>initial</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>opts</QName><TOKEN>:=</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"id"</StringLiteral><TOKEN>:</TOKEN><StringLiteral>"66"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN> <MapConstructorEntry><StringLiteral>"log"</StringLiteral><TOKEN>:</TOKEN><FunctionCall><QName>true</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MapConstructorEntry><TOKEN>,</TOKEN><MapConstructorEntry><StringLiteral>"trace"</StringLiteral><TOKEN>:</TOKEN><FunctionCall><QName>true</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>_</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:log</QName><ArgumentList><TOKEN>(</TOKEN> <StringConcatExpr><StringLiteral>"start: "</StringLiteral> <TOKEN>||</TOKEN> <FunctionCall><TOKEN>count</TOKEN><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>initial</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></StringConcatExpr><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>steps</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>pipe</QName></VarRef><TOKEN>/</TOKEN><AxisStep><Wildcard>qipe:*</Wildcard>
  <PredicateList/></AxisStep></RelativePathExpr></LetBinding></LetClause><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>result</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>fold-left</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>steps</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>initial</QName></VarRef><TOKEN>,</TOKEN><FunctionCall><QName>qipe:step</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
          <Expr><VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef><TOKEN>,</TOKEN>
          <FunctionCall><QName>qipe:log</QName><ArgumentList><TOKEN>(</TOKEN> <StringLiteral>"end: "</StringLiteral><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></Expr>
        <TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:run</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>pipe</QName> <TypeDeclaration><TOKEN>as</TOKEN> <AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest></TypeDeclaration></Param> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FunctionCall><QName>qipe:run</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>pipe</QName></VarRef><TOKEN>,</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ check pipeline is valid against schema :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:validate-pipeline</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>pipe</QName> <TypeDeclaration><TOKEN>as</TOKEN> <DocumentTest><TOKEN>document-node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></DocumentTest></TypeDeclaration></Param> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <DocumentTest><TOKEN>document-node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></DocumentTest>
<EnclosedExpr><TOKEN>{</TOKEN>
 <Expr><FunctionCall><QName>validate:rng</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>pipe</QName></VarRef> <TOKEN>,</TOKEN> <StringLiteral>"schemas/pipeline.rnc"</StringLiteral><TOKEN>,</TOKEN><FunctionCall><QName>true</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>pipe</QName></VarRef></Expr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  run a step 
 : @param $acc current state
 : @param $this current step as qipe:* element
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:step</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName> <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <TypeswitchExpr><TOKEN>typeswitch</TOKEN><TOKEN>(</TOKEN><ArrowExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>=&gt;</TOKEN><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"RUNNING:"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr><TOKEN>)</TOKEN>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:validate</QName><TOKEN>)</TOKEN></ElementTest>  <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:validate</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:xquery</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:xquery</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:xslt</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:xslt</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:load</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:load</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:store</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:store</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:directory-list</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:dir</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:pipeline</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:pipeline</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <CaseClause><TOKEN>case</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:identity</QName><TOKEN>)</TOKEN></ElementTest> <TOKEN>return</TOKEN> <FunctionCall><QName>qipe:identity</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></CaseClause>
  <TOKEN>default</TOKEN> <TOKEN>return</TOKEN> <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>xs:QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'qipe'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN> <StringConcatExpr><StringLiteral>'unknown step:'</StringLiteral> <TOKEN>||</TOKEN> <FunctionCall><QName>name</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></StringConcatExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></TypeswitchExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  subpipe
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:pipeline</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName> <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:pipeline</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>a</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:run</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  identity
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:identity</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName> <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:pipeline</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
   <ArrowExpr><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>=&gt;</TOKEN><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"IDENT"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>
 
(:~  run validate step based on @type
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:validate</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName> <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:validate</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:resolve</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>href</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>failOnError</QName><TOKEN>:=</TOKEN><FunctionCall><QName>boolean</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>failOnError</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>fn</QName><TOKEN>:=</TOKEN> <SwitchExpr><TOKEN>switch</TOKEN> <TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>type</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr><TOKEN>)</TOKEN>
             <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"relax-ng"</StringLiteral> <TOKEN>return</TOKEN>  <FunctionCall><QName>qipe:relax-ng</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
             <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"schematron"</StringLiteral> <TOKEN>return</TOKEN>  <FunctionCall><QName>qipe:schematron</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
             <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"xml-schema"</StringLiteral> <TOKEN>return</TOKEN>  <FunctionCall><QName>qipe:validate-xsd</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
             <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"dtd"</StringLiteral> <TOKEN>return</TOKEN>  <FunctionCall><QName>qipe:validate-dtd</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
             <TOKEN>default</TOKEN> <TOKEN>return</TOKEN> <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>xs:QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'qipe'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN> <StringConcatExpr><StringLiteral>'unknown validation type: '</StringLiteral> <TOKEN>||</TOKEN> <RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>type</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></StringConcatExpr> <TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchExpr></LetBinding></LetClause>
  <ForClause><TOKEN>for</TOKEN>  <ForBinding><TOKEN>$</TOKEN><QName>doc</QName> <PositionalVar><TOKEN>at</TOKEN> <TOKEN>$</TOKEN><QName>i</QName></PositionalVar> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef></ForBinding></ForClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>report</QName><TOKEN>:=</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>fn</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>_</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:log</QName><ArgumentList><TOKEN>(</TOKEN><StringConcatExpr><StringLiteral>"validate: "</StringLiteral> <TOKEN>||</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef></StringConcatExpr><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  
  <ReturnClause><TOKEN>return</TOKEN>  
         <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><ComparisonExpr><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>report</QName></VarRef><TOKEN>/</TOKEN><AxisStep><QName>status</QName> <PredicateList/></AxisStep></RelativePathExpr><TOKEN>=</TOKEN> <StringLiteral>"valid"</StringLiteral></ComparisonExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
             <VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef>
         <TOKEN>else</TOKEN>
           <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>_</QName><TOKEN>:=</TOKEN><FunctionCall><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>report</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>"validation errors"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
           <ReturnClause><TOKEN>return</TOKEN>  <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>failOnError</QName></VarRef><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
                        <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>xs:QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'qipe'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN> 
                        <StringConcatExpr><StringLiteral>' validation fails: '</StringLiteral> <TOKEN>||</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef> <TOKEN>||</TOKEN> <StringLiteral>"="</StringLiteral> <TOKEN>||</TOKEN> <FunctionCall><QName>base-uri</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></StringConcatExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
                   <TOKEN>else</TOKEN>
                       <VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef></IfExpr></ReturnClause></FLWORExpr></IfExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  
 : append directory-list  to accumulator
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:dir</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:directory-list</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>inc</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>include-filter</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>href</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>result</QName><TOKEN>:=</TOKEN><FunctionCall><QName>fw:directory-list</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"include-filter"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>inc</QName></VarRef></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>result</QName><TOKEN>:=</TOKEN> <TransformWithExpr><CompDocConstructor><TOKEN>document</TOKEN> <EnclosedExpr><TOKEN>{</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef> <TOKEN>}</TOKEN></EnclosedExpr></CompDocConstructor> <TOKEN>transform</TOKEN> <TOKEN>with</TOKEN> <TOKEN>{</TOKEN> <DeleteExpr><TOKEN>delete</TOKEN>  <TOKEN>node</TOKEN> <PathExpr><TOKEN>//</TOKEN><AxisStep><QName>c:directory</QName><Predicate><TOKEN>[</TOKEN><FunctionCall><QName>not</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><TOKEN>.</TOKEN><TOKEN>//</TOKEN><AxisStep><QName>c:file</QName><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>]</TOKEN></Predicate></AxisStep></PathExpr></DeleteExpr><TOKEN>}</TOKEN></TransformWithExpr></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN><Expr><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  
 : run xquery referenced by @href and append result sequence to accumulator
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:xquery</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:xquery</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><ArrowExpr><FunctionCall><QName>resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>href</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>,</TOKEN><FunctionCall><QName>base-uri</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=&gt;</TOKEN><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"AT"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>result</QName><TOKEN>:=</TOKEN><FunctionCall><QName>xquery:invoke</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>''</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN><Expr><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  
 : apply XSLT transform to each item in accumulator
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:xslt</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:xslt</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><ArrowExpr><FunctionCall><QName>qipe:resolve</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>href</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=&gt;</TOKEN><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"XSLT"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></LetBinding></LetClause>
  <ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>d</QName> <PositionalVar><TOKEN>at</TOKEN> <TOKEN>$</TOKEN><QName>i</QName></PositionalVar> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef></ForBinding></ForClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>_</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:log</QName><ArgumentList><TOKEN>(</TOKEN><StringConcatExpr><StringLiteral>"xslt: "</StringLiteral> <TOKEN>||</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef></StringConcatExpr><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>_</QName><TOKEN>:=</TOKEN><FunctionCall><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>d</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>"ddd"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>xslt:transform</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>d</QName></VarRef><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>  
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  
 : store each item in accumulator at computed path
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:store</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>qipe:store</QName><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><FunctionCall><QName>qipe:resolve</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>base</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>dated</QName><TOKEN>:=</TOKEN><FunctionCall><QName>boolean</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>dated</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>name</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>fileExpression</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>output</QName><TOKEN>:=</TOKEN><PostfixExpr><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>output</QName></AbbrevForwardStep><PredicateList/></AxisStep><TOKEN>/</TOKEN><FunctionCall><QName>string</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr><TOKEN>,</TOKEN><StringLiteral>"xml"</StringLiteral></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><Predicate><TOKEN>[</TOKEN><IntegerLiteral>1</IntegerLiteral><TOKEN>]</TOKEN></Predicate></PostfixExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>eval</QName><TOKEN>:=</TOKEN><StringConcatExpr><StringLiteral>"declare variable $position external :=0; "</StringLiteral> <TOKEN>||</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef></StringConcatExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><StringConcatExpr><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>||</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>dated</QName></VarRef><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> 
                          <FunctionCall><QName>format-date</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>current-date</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN><StringLiteral>"/[Y0001][M01][D01]"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall> 
                       <TOKEN>else</TOKEN> 
                          <ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></IfExpr><TOKEN>)</TOKEN></ParenthesizedExpr></StringConcatExpr></LetBinding></LetClause>
  
          <ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><TOKEN>item</TOKEN> <PositionalVar><TOKEN>at</TOKEN> <TOKEN>$</TOKEN><QName>pos</QName></PositionalVar> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef></ForBinding></ForClause>
          <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>name</QName><TOKEN>:=</TOKEN><FunctionCall><QName>xquery:eval</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>eval</QName></VarRef><TOKEN>,</TOKEN>
                                 <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>""</StringLiteral><TOKEN>:</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef></MapConstructorEntry><TOKEN>,</TOKEN>
                                     <MapConstructorEntry><StringLiteral>"position"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>pos</QName></VarRef></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause> (:eval against doc:)
          <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>dest</QName><TOKEN>:=</TOKEN><StringConcatExpr><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef> <TOKEN>||</TOKEN> <StringLiteral>"/"</StringLiteral> <TOKEN>||</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef></StringConcatExpr></LetBinding></LetClause>
          <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>dir</QName><TOKEN>:=</TOKEN><FunctionCall><QName>file:parent</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dest</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
          <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
                 <Expr><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef>
                 <TOKEN>,</TOKEN><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>file:is-dir</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dir</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr> <TOKEN>else</TOKEN> <FunctionCall><QName>file:create-dir</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dir</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></IfExpr>
                 <TOKEN>,</TOKEN><FunctionCall><QName>file:write</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dest</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>qipe:outputs</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>output</QName></VarRef><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></Expr>
                 <TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  validate with xml-schema  :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:validate-xsd</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>doc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>xsd</QName></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>report</QName><TOKEN>)</TOKEN></ElementTest>
<EnclosedExpr><TOKEN>{</TOKEN> 
  <FunctionCall><QName>validate:xsd-report</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xsd</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  validate with dtd  :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:validate-dtd</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>doc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>dtd</QName></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>report</QName><TOKEN>)</TOKEN></ElementTest>
<EnclosedExpr><TOKEN>{</TOKEN> 
  <FunctionCall><QName>validate:dtd-report</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dtd</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  validate with relax-ng  :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:relax-ng</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>doc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>rng</QName></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>report</QName><TOKEN>)</TOKEN></ElementTest>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>compact</QName><TOKEN>:=</TOKEN><FunctionCall><QName>matches</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>rng</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>".*\.rnc"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
 <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>validate:rng-report</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>rng</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>compact</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~ 
 : validate with schematron
 : NOTE: relative paths in doc() references in schematron may cause issues  
  :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:schematron</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>doc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>uri-sch</QName></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>report</QName><TOKEN>)</TOKEN></ElementTest>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>sch</QName> <TOKEN>:=</TOKEN> <FunctionCall><QName>schematron:compile</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>doc</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>uri-sch</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>svrl</QName> <TOKEN>:=</TOKEN> <FunctionCall><QName>schematron:validate</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>sch</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <DirElemConstructor><TOKEN>&lt;</TOKEN><QName>report</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>status</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><EnclosedExpr><TOKEN>{</TOKEN>
              <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>schematron:is-valid</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>svrl</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <StringLiteral>'valid'</StringLiteral> <TOKEN>else</TOKEN> <StringLiteral>'invalid'</StringLiteral></IfExpr>
            <TOKEN>}</TOKEN></EnclosedExpr><TOKEN>&lt;/</TOKEN><QName>status</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><VarRef><TOKEN>$</TOKEN><QName>svrl</QName></VarRef><TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><TOKEN>&lt;/</TOKEN><QName>report</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></ReturnClause></FLWORExpr>          
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  load from file system  :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:load</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>this</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList> <TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN> 
 <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>href</QName><TOKEN>:=</TOKEN><ArrowExpr><FunctionCall><QName>qipe:resolve</QName><ArgumentList><TOKEN>(</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>this</QName></VarRef><TOKEN>/</TOKEN><AxisStep><AbbrevForwardStep><TOKEN>@</TOKEN><QName>href</QName></AbbrevForwardStep><PredicateList/></AxisStep></RelativePathExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=&gt;</TOKEN><QName>trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"load"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></LetBinding></LetClause>
 <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>new</QName><TOKEN>:=</TOKEN><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>file:is-dir</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>  
                <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>xs:QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'qipe'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN> <StringLiteral>'dir loading not implemented'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall> (: @TODO load all:)
            <TOKEN>else</TOKEN> 
               <FunctionCall><QName>doc</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></IfExpr></LetBinding></LetClause>
 <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN><Expr><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>new</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  resolve locations relative to this document typically from @href :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:resolve</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>href</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><AnyKindTest><TOKEN>node</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></AnyKindTest><TOKEN>?</TOKEN></SequenceType></TypeDeclaration></Param> <TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN> 
 <FunctionCall><QName>resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>,</TOKEN><FunctionCall><QName>base-uri</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>href</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~  log msg :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>qipe:log</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><TOKEN>text</TOKEN> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><TOKEN>empty-sequence</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN> 
 <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>log</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
      <FunctionCall><QName>admin:write-log</QName><ArgumentList><TOKEN>(</TOKEN><StringConstructor><TOKEN>``[</TOKEN><StringConstructorContent><StringConstructorChars>[</StringConstructorChars><StringConstructorInterpolation><TOKEN>`{</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>id</NCName></Lookup></PostfixExpr> <TOKEN>}`</TOKEN></StringConstructorInterpolation><StringConstructorChars>] </StringConstructorChars><StringConstructorInterpolation><TOKEN>`{</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>text</TOKEN></VarRef><TOKEN>}`</TOKEN></StringConstructorInterpolation><StringConstructorChars/></StringConstructorContent><TOKEN>]``</TOKEN></StringConstructor><TOKEN>,</TOKEN><StringLiteral>"QIPE"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
 <TOKEN>else</TOKEN>    
   <ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr></IfExpr>        
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog></LibraryModule><EOF/></XQuery>