<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2019-05-24T10:30:30.92+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum.tools.buildfields</xqdoc:uri><xqdoc:name>entity-gen.xqm</xqdoc:name><xqdoc:comment><xqdoc:description>generate xquery access code for entity definitions</xqdoc:description><xqdoc:custom tag="__source">lib/entity-gen.xqm</xqdoc:custom></xqdoc:comment><xqdoc:body>(:~ 
 : generate xquery access code for entity definitions
 :)
module namespace bf = 'quodatum.tools.buildfields';
declare default function namespace 'quodatum.tools.buildfields'; 
declare namespace ent="https://github.com/Quodatum/app-doc/entity"; 


(:~
 : generate xquery module for given entities as a string
 :)
declare function module($entities as element(ent:entity)*,$imports)
as xs:string
{
let $src:= &lt;text&gt;(: entity access maps 
 : auto generated from xml files in entities folder at: {fn:current-dateTime()} 
 :)

module namespace entity = 'quodatum.models.generated';
{$imports}

{bf:build-imports($entities)}
{bf:build-namespaces($entities)}
{(  bf:build-describe($entities))} 

(:~ map of access functions for entity :)
declare function entity:fields($entity as xs:string)
as map(*){{
  $entity:list($entity)("access")
}}; 
  &lt;/text&gt; 

 return $src
};

(:~
 : generate xquery for to return field value in the format: "name":function($_){}
 :)
declare function accessfn($f as element(ent:field)) as xs:string
{
let $type:=$f/@type/fn:string()
return &lt;field&gt;
       "{$f/@name/fn:string()}": function($_ as element()) as {$type} {{$_/{$f/ent:xpath } }}&lt;/field&gt;
};

declare function generate($e as element(ent:entity)) as xs:string
{
  let $fields:=for $field in $e/ent:fields/ent:field   
                order by $field/@name
                return $field
                
  let $filter:=$e/ent:views/ent:view[@name="filter"]=&gt;fn:tokenize()
  let $filter:= $e/ent:fields/ent:field[@name=$filter]/ent:xpath/fn:concat("$item/",.) 
                   
  return &lt;field&gt;
  "{$e/@name/fn:string()}": map{{
     "name": "{ $e/@name/fn:string()}",
     "description": "{ escape($e/ent:description)}",
     "access": map{{ {$fields!accessfn(.)=&gt;fn:string-join(",")} }},
    
     "filter": function($item,$q) as xs:boolean{{ 
         some $e in ( {fn:string-join($filter,", ")}) satisfies
         fn:contains($e,$q, 'http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive')
      }},
       "json":   map{{ {$fields!jsonfn(.)=&gt;fn:string-join(",")} }},
       
      "data": function() as {$e/ent:data/@type/fn:string(.)}*
       {{ {let $a:=$e/ent:data/fn:string() return if($a)then $a else "()"} }},
       
       "views": map{{ 
       {$e/ent:views/ent:view!("'" || @name || "': '" ||. || "'")=&gt;fn:string-join(',')}
       }}
   }}&lt;/field&gt;
};

(:~
 : @return sequence of element(entity) items for definitions at path
 :)
declare function entities($path as xs:string) 
as element(ent:entity)*
{
let $_:=fn:trace($path,"DD")
 let $p:=fn:resolve-uri($path) || "/"
 return for $f in file:list($p)
        order by $f
        return fn:doc(fn:concat($p,$f))/ent:entity
};

(:map for entity :)
declare function build-map($entity as element(ent:entity)) 
as xs:string
{
let $m:=for $field in $entity/ent:fields/ent:field   
        order by $field/@name
        return accessfn($field)
return &lt;text&gt;
declare variable $entity:{$entity/@name/fn:string()}: map{{ {fn:string-join($m,",")}
}};

&lt;/text&gt;        
};

(:~ 
 :  return xml for suitable json serialization for field 
:)
declare function jsonfn($f as element(ent:field)) 
as xs:string
{
    let $name:=$f/@name/fn:string()
    let $type:=$f/@type/fn:string()
    let $opt:=fn:contains($type,"?")
    let $repeat:=fn:contains($type,"*")
    let $json-type:=json-type($type)
    let $mult:=if($repeat) then "*" else "?"
    
    let $at:=if($json-type ne "string") 
            then "attribute type {'" || $json-type || "'},"
            else "" 
    (: generate json xml :)
    let $simple:=function() as xs:string{
                &lt;field&gt;(: {$type} :)
                        fn:data($_/{$f/ent:xpath })!element {$name} {{ {$at} .}} 
                &lt;/field&gt;
                }
    let $array:=function() as xs:string{
                &lt;field&gt;(: array of strings :)
                   element {$name} {{ 
                        attribute type {{"array"}},
                        $_/{$f/ent:xpath }!element _ {{ attribute type {{"string"}}, .}}
                        }} 
                &lt;/field&gt;
                }            
    (: serialize when element :)
    let $element:=function() as xs:string{
                &lt;field&gt;element {$name} {{ 
                     attribute type {{"string"}},
                     fn:serialize($_/{$f/ent:xpath})}}&lt;/field&gt;
                } 
                    
    return &lt;field&gt;
           "{$name}": function($_ as element()) as element({$name}){$mult} {{
            {if($repeat)then
             $array() 
            else if($type="element()") then 
               $element() 
             else $simple()} }}&lt;/field&gt;
};


(:~ convert xs type to json
:)
declare function json-type($xsd as xs:string) as xs:string{
switch ($xsd)
   case "element()" return "string" 
   case "xs:boolean" return "boolean"
   case "xs:integer" return "number"
   case "xs:float" return "number"
   case "xs:double" return "number"
   case "xs:string*" return "array"
   default return "string" 
};

(:~ declare any namespaces found :)
declare function build-namespaces($entities as element()*)
{
  for $n in distinct-deep($entities/ent:namespace)
  return 
&lt;text&gt;declare namespace {$n/@prefix/fn:string()}='{$n/@uri/fn:string()}';
&lt;/text&gt;
};

(:~ import any modules found must be in repo :)
declare function build-imports($entities as element()*)
{
  for $n in distinct-deep($entities/ent:module)
  return 
&lt;text&gt;import module namespace {$n/@prefix/fn:string()}='{$n/@namespace/fn:string()}';
&lt;/text&gt;
};

declare function build-describe($entities)
as xs:string
{
  let $m:=for $e in  $entities
          return generate($e)
  return &lt;text&gt;          
declare variable $entity:list:=map {{ {fn:string-join($m,",")}
}};

&lt;/text&gt;        
};

declare function escape($str as xs:string) 
as xs:string
{
   fn:replace(
     fn:replace($str,'"','""'),
     "'","''")
};

(:-----from functx-------------------:)

 declare function distinct-deep 
  ( $nodes as node()* )  as node()* {
       
    for $seq in (1 to fn:count($nodes))
    return $nodes[$seq][fn:not(is-node-in-sequence-deep-equal(
                          .,$nodes[fn:position() &lt; $seq]))]
};

declare function is-node-in-sequence-deep-equal 
  ( $node as node()? ,
    $seq as node()* )  as xs:boolean {
       
   some $nodeInSeq in $seq satisfies fn:deep-equal($nodeInSeq,$node)
 } ; </xqdoc:body></xqdoc:module><xqdoc:namespaces><xqdoc:namespace prefix="bf" uri="quodatum.tools.buildfields"/><xqdoc:namespace prefix="ent" uri="https://github.com/Quodatum/app-doc/entity"/></xqdoc:namespaces><xqdoc:imports/><xqdoc:variables/><xqdoc:functions><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>generate xquery module for given entities as a string</xqdoc:description></xqdoc:comment><xqdoc:name>module</xqdoc:name><xqdoc:signature>declare function module($entities as element(ent:entity)*, $imports as item()*) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>entities</xqdoc:name><xqdoc:type occurrence="*">element(ent:entity)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>imports</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>generate xquery for to return field value in the format: "name":function($_){}</xqdoc:description></xqdoc:comment><xqdoc:name>accessfn</xqdoc:name><xqdoc:signature>declare function accessfn($f as element(ent:field)) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>f</xqdoc:name><xqdoc:type>element(ent:field)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>generate</xqdoc:name><xqdoc:signature>declare function generate($e as element(ent:entity)) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(ent:entity)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description/><xqdoc:return>sequence of element(entity) items for definitions at path</xqdoc:return></xqdoc:comment><xqdoc:name>entities</xqdoc:name><xqdoc:signature>declare function entities($path as xs:string) as element(ent:entity)*</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>path</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">element(ent:entity)</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>build-map</xqdoc:name><xqdoc:signature>declare function build-map($entity as element(ent:entity)) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>entity</xqdoc:name><xqdoc:type>element(ent:entity)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>return xml for suitable json serialization for field</xqdoc:description></xqdoc:comment><xqdoc:name>jsonfn</xqdoc:name><xqdoc:signature>declare function jsonfn($f as element(ent:field)) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>f</xqdoc:name><xqdoc:type>element(ent:field)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>convert xs type to json</xqdoc:description></xqdoc:comment><xqdoc:name>json-type</xqdoc:name><xqdoc:signature>declare function json-type($xsd as xs:string) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>xsd</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>declare any namespaces found</xqdoc:description></xqdoc:comment><xqdoc:name>build-namespaces</xqdoc:name><xqdoc:signature>declare function build-namespaces($entities as element()*) as item()*</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>entities</xqdoc:name><xqdoc:type occurrence="*">element()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>import any modules found must be in repo</xqdoc:description></xqdoc:comment><xqdoc:name>build-imports</xqdoc:name><xqdoc:signature>declare function build-imports($entities as element()*) as item()*</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>entities</xqdoc:name><xqdoc:type occurrence="*">element()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>build-describe</xqdoc:name><xqdoc:signature>declare function build-describe($entities as item()*) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>entities</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>escape</xqdoc:name><xqdoc:signature>declare function escape($str as xs:string) as xs:string</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>str</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>distinct-deep</xqdoc:name><xqdoc:signature>declare function distinct-deep($nodes as node()*) as node()*</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>nodes</xqdoc:name><xqdoc:type occurrence="*">node()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">node()</xqdoc:type></xqdoc:return></xqdoc:function><xqdoc:function arity="2"><xqdoc:name>is-node-in-sequence-deep-equal</xqdoc:name><xqdoc:signature>declare function is-node-in-sequence-deep-equal($node as node()?, $seq as node()*) as xs:boolean</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>node</xqdoc:name><xqdoc:type occurrence="?">node()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>seq</xqdoc:name><xqdoc:type occurrence="*">node()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:return></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>