<XQuery><Module><VersionDecl><TOKEN>xquery</TOKEN> <TOKEN>version</TOKEN> <StringLiteral>"3.1"</StringLiteral><TOKEN>;</TOKEN></VersionDecl>
<LibraryModule><ModuleDecl><TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>mt</NCName> <TOKEN>=</TOKEN> <StringLiteral>'quodatum.data.mimetype'</StringLiteral><TOKEN>;</TOKEN></ModuleDecl>
<Prolog><NamespaceDecl><TOKEN>declare</TOKEN> <TOKEN>namespace</TOKEN> <NCName>MediaType</NCName><TOKEN>=</TOKEN><StringLiteral>'java:org.basex.util.http.MediaType'</StringLiteral></NamespaceDecl><TOKEN>;</TOKEN>
<AnnotatedDecl><TOKEN>declare</TOKEN> <Annotation><TOKEN>%</TOKEN><QName>basex:lazy</QName></Annotation> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>mt:lines</QName><TOKEN>:=</TOKEN><ArrowExpr><StringLiteral>"media-types.properties"</StringLiteral><TOKEN>=&gt;</TOKEN><QName>fn:unparsed-text-lines</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>
(:~ 
 : fetch function for given data type "text","xml","binary"
: @return function()
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>mt:fetch-fn</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><TOKEN>treat</TOKEN> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <AnyFunctionTest><TOKEN>function</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></AnyFunctionTest>
<EnclosedExpr><TOKEN>{</TOKEN>
     <SwitchExpr><TOKEN>switch</TOKEN>  <TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>treat</TOKEN></VarRef><TOKEN>)</TOKEN> 
     <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"text"</StringLiteral>
          <TOKEN>return</TOKEN> <FunctionCall><QName>fetch:text</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
     <SwitchCaseClause><TOKEN>case</TOKEN> <StringLiteral>"xml"</StringLiteral> 
          <TOKEN>return</TOKEN> <FunctionCall><QName>fetch:text</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchCaseClause>
     <TOKEN>default</TOKEN> 
          <TOKEN>return</TOKEN> <FunctionCall><QName>fetch:binary</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>?</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></SwitchExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ get mediatype and dataformat as map
 : @return e.g. {type:"application/xml","treat-as":"xml"}
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>mt:type</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>filepath</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType>
<EnclosedExpr><TOKEN>{</TOKEN>
<FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>f</QName><TOKEN>:=</TOKEN><StringConcatExpr><StringLiteral>"a."</StringLiteral> <TOKEN>||</TOKEN> <FunctionCall><QName>mt:base-ext</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>filepath</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></StringConcatExpr></LetBinding></LetClause>
<LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>a</QName><TOKEN>:=</TOKEN><FunctionCall><QName>MediaType:get</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>f</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
<LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>type</QName><TOKEN>:=</TOKEN> <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><ComparisonExpr><VarRef><TOKEN>$</TOKEN><QName>a</QName></VarRef><TOKEN>=</TOKEN><StringLiteral>"application/sparql-query"</StringLiteral></ComparisonExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> 
                 <StringLiteral>"text"</StringLiteral>
            <TOKEN>else</TOKEN> <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>MediaType:isXML</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>a</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> 
                 <StringLiteral>"xml"</StringLiteral>
            <TOKEN>else</TOKEN> <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><OrExpr><FunctionCall><QName>MediaType:isText</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>a</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>or</TOKEN> <FunctionCall><QName>MediaType:isXQuery</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>a</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></OrExpr><TOKEN>)</TOKEN><TOKEN>then</TOKEN>
                <StringLiteral>"text"</StringLiteral>
            <TOKEN>else</TOKEN>
               <StringLiteral>"binary"</StringLiteral></IfExpr></IfExpr></IfExpr></LetBinding></LetClause>
 <ReturnClause><TOKEN>return</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"type"</StringLiteral><TOKEN>:</TOKEN> <FunctionCall><QName>MediaType:type</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>a</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MapConstructorEntry> <TOKEN>,</TOKEN>
            <MapConstructorEntry><StringLiteral>"treat-as"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>type</QName></VarRef></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~ treat as extension
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>mt:base-ext</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>filepath</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>ext</QName><TOKEN>:=</TOKEN><ArrowExpr><FunctionCall><QName>file:name</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>filepath</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=&gt;</TOKEN><QName>substring-after</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"."</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>types</QName><TOKEN>:=</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"vue"</StringLiteral><TOKEN>:</TOKEN><StringLiteral>".html"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN><MapConstructorEntry><StringLiteral>"sch"</StringLiteral><TOKEN>:</TOKEN><StringLiteral>".xml"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <ArrowExpr><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>types</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ext</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ext</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>=&gt;</TOKEN><QName>head</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
: map of keys:all mimetypes, values: extensions  as array
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>mt:types</QName><TOKEN>(</TOKEN><TOKEN>)</TOKEN><EnclosedExpr><TOKEN>{</TOKEN>
<FunctionCall><QName>fold-left</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>mt:lines</QName></VarRef><TOKEN>,</TOKEN>
         <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><TOKEN>}</TOKEN></MapConstructor><TOKEN>,</TOKEN>
         <InlineFunctionExpr><TOKEN>function</TOKEN><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>acc</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>line</QName></Param></ParamList><TOKEN>)</TOKEN><EnclosedExpr><TOKEN>{</TOKEN>
              <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>p</QName><TOKEN>:=</TOKEN><FunctionCall><QName>tokenize</QName> <ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>line</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>"="</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
              <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>map:merge</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><VarRef><TOKEN>$</TOKEN><QName>acc</QName></VarRef><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><FunctionCall><QName>tail</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>p</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>:</TOKEN><FunctionCall><QName>head</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>p</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN> <TOKEN>{</TOKEN> <MapConstructorEntry><StringLiteral>'duplicates'</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>'combine'</StringLiteral></MapConstructorEntry> <TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>
             <TOKEN>}</TOKEN></EnclosedExpr></InlineFunctionExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
 <TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog></LibraryModule></Module> <EOF/></XQuery>