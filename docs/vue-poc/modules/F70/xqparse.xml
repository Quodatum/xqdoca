<XQuery>(:~
 : Utility functions.
 :
 : @author Christian Gr√ºn, BaseX Team, 2014-16
 :)
<LibraryModule><ModuleDecl><TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>util</NCName> <TOKEN>=</TOKEN> <StringLiteral>'vue-poc/util'</StringLiteral><TOKEN>;</TOKEN></ModuleDecl>

<Prolog><ModuleImport><TOKEN>import</TOKEN> <TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>cons</NCName> <TOKEN>=</TOKEN> <StringLiteral>'vue-poc/cons'</StringLiteral> <TOKEN>at</TOKEN> <StringLiteral>'cons.xqm'</StringLiteral></ModuleImport><TOKEN>;</TOKEN>

(:~
 : Evaluates a query and returns the result.
 : @param  $query    query string
 : @param  $context  initial context value
 : @return serialized result of query
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:query</QName><TOKEN>(</TOKEN>
  <ParamList><Param><TOKEN>$</TOKEN><QName>query</QName>    <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><QName>xs:string</QName><TOKEN>?</TOKEN></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>context</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN> 
<TOKEN>as</TOKEN> <QName>xs:string</QName> <EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>result</QName> <TOKEN>:=</TOKEN> <FunctionCall><QName>xquery:eval</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>query</QName></VarRef><TOKEN>,</TOKEN> <MapConstructor><TOKEN>map</TOKEN> <TOKEN>{</TOKEN> <MapConstructorEntry><StringLiteral>''</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>context</QName></VarRef></MapConstructorEntry> <TOKEN>}</TOKEN></MapConstructor><TOKEN>,</TOKEN> <FunctionCall><QName>util:query-options</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  (: serialize more characters than requested, because limit represents number of bytes :)
  <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>util:display</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:display</QName><TOKEN>(</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>result</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <QName>xs:string</QName> 
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>limit</QName> <TOKEN>:=</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-MAXCHARS</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></LetBinding></LetClause>
  (: serialize more characters than requested, because limit represents number of bytes :)
  <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>util:chop</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>serialize</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>result</QName></VarRef><TOKEN>,</TOKEN> <MapConstructor><TOKEN>map</TOKEN> <TOKEN>{</TOKEN> <MapConstructorEntry><StringLiteral>'limit'</StringLiteral><TOKEN>:</TOKEN> <AdditiveExpr><MultiplicativeExpr><VarRef><TOKEN>$</TOKEN><QName>limit</QName></VarRef> <TOKEN>*</TOKEN> <IntegerLiteral>2</IntegerLiteral></MultiplicativeExpr> <TOKEN>+</TOKEN> <IntegerLiteral>1</IntegerLiteral></AdditiveExpr></MapConstructorEntry><TOKEN>,</TOKEN> <MapConstructorEntry><StringLiteral>'method'</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>'basex'</StringLiteral></MapConstructorEntry> <TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>limit</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>
(:~
 : Runs an updating query.
 : @param  $query  query string
 : @return empty sequence
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <Annotation><TOKEN>%</TOKEN><QName>updating</QName></Annotation> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:update-query</QName><TOKEN>(</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>query</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><QName>xs:string</QName><TOKEN>?</TOKEN></SequenceType></TypeDeclaration></Param>
<TOKEN>)</TOKEN> <EnclosedExpr><TOKEN>{</TOKEN>
  <FunctionCall><QName>xquery:eval-update</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>query</QName></VarRef><TOKEN>,</TOKEN> <MapConstructor><TOKEN>map</TOKEN> <TOKEN>{</TOKEN> <TOKEN>}</TOKEN></MapConstructor><TOKEN>,</TOKEN> <FunctionCall><QName>util:query-options</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : Returns the options for evaluating a query.
 : @return options
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <Annotation><TOKEN>%</TOKEN><QName>private</QName></Annotation> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:query-options</QName><TOKEN>(</TOKEN><TOKEN>)</TOKEN> <TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType> <EnclosedExpr><TOKEN>{</TOKEN>
  <MapConstructor><TOKEN>map</TOKEN> <TOKEN>{</TOKEN>
    <MapConstructorEntry><StringLiteral>'timeout'</StringLiteral>   <TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-TIMEOUT</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN>
    <MapConstructorEntry><StringLiteral>'memory'</StringLiteral>    <TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-MEMORY</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN>
    <MapConstructorEntry><StringLiteral>'permission'</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-PERMISSION</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></MapConstructorEntry>
  <TOKEN>}</TOKEN></MapConstructor>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : Checks if the specified binary input can be converted to an XML string.
 : @param  $input  input
 : @return XML string
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:to-xml-string</QName><TOKEN>(</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>input</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:base64Binary</QName></TypeDeclaration></Param>
<TOKEN>)</TOKEN> <TOKEN>as</TOKEN> <QName>xs:string</QName> <EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>string</QName> <TOKEN>:=</TOKEN>
    <TryCatchExpr><TryClause><TOKEN>try</TOKEN> <EnclosedExpr><TOKEN>{</TOKEN>
      <FunctionCall><QName>convert:binary-to-string</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>input</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
    <TOKEN>}</TOKEN></EnclosedExpr></TryClause> <CatchClause><TOKEN>catch</TOKEN> <Wildcard>*</Wildcard> <EnclosedExpr><TOKEN>{</TOKEN>
      <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>,</TOKEN> <StringLiteral>"Input is no valid UTF8 string."</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
    <TOKEN>}</TOKEN></EnclosedExpr></CatchClause></TryCatchExpr></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN>
    <TryCatchExpr><TryClause><TOKEN>try</TOKEN> <EnclosedExpr><TOKEN>{</TOKEN>
      (: tries to convert the input to XML, but discards the results :)
      <Expr><FunctionCall><QName>prof:void</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>parse-xml</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>string</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN>
      <VarRef><TOKEN>$</TOKEN><QName>string</QName></VarRef></Expr>
    <TOKEN>}</TOKEN></EnclosedExpr></TryClause> <CatchClause><TOKEN>catch</TOKEN> <Wildcard>*</Wildcard> <EnclosedExpr><TOKEN>{</TOKEN>
      <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>,</TOKEN> <StringLiteral>"Input is no well-formed XML."</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
    <TOKEN>}</TOKEN></EnclosedExpr></CatchClause></TryCatchExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : Returns the index of the first result to generate.
 : @param  $page  current page
 : @param  $sort  sort key
 : @return last result
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:start</QName><TOKEN>(</TOKEN>
  <ParamList><Param><TOKEN>$</TOKEN><QName>page</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:integer</QName></TypeDeclaration></Param><TOKEN>,</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>sort</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param></ParamList>
<TOKEN>)</TOKEN> <TOKEN>as</TOKEN> <QName>xs:integer</QName> <EnclosedExpr><TOKEN>{</TOKEN>
  <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><AndExpr><VarRef><TOKEN>$</TOKEN><QName>page</QName></VarRef> <TOKEN>and</TOKEN> <FunctionCall><QName>not</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></AndExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <AdditiveExpr><MultiplicativeExpr><ParenthesizedExpr><TOKEN>(</TOKEN><AdditiveExpr><VarRef><TOKEN>$</TOKEN><QName>page</QName></VarRef> <TOKEN>-</TOKEN> <IntegerLiteral>1</IntegerLiteral></AdditiveExpr><TOKEN>)</TOKEN></ParenthesizedExpr> <TOKEN>*</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-MAXROWS</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></MultiplicativeExpr> <TOKEN>+</TOKEN> <IntegerLiteral>1</IntegerLiteral></AdditiveExpr>
  <TOKEN>)</TOKEN></ParenthesizedExpr> <TOKEN>else</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <IntegerLiteral>1</IntegerLiteral>
  <TOKEN>)</TOKEN></ParenthesizedExpr></IfExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : Returns the index of the last result to generate.
 : @param  $page  current page
 : @param  $sort  sort key
 : @return last result
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:end</QName><TOKEN>(</TOKEN>
  <ParamList><Param><TOKEN>$</TOKEN><QName>page</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:integer</QName></TypeDeclaration></Param><TOKEN>,</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>sort</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param></ParamList>
<TOKEN>)</TOKEN> <TOKEN>as</TOKEN> <QName>xs:integer</QName> <EnclosedExpr><TOKEN>{</TOKEN>
  <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><AndExpr><VarRef><TOKEN>$</TOKEN><QName>page</QName></VarRef> <TOKEN>and</TOKEN> <FunctionCall><QName>not</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></AndExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <MultiplicativeExpr><VarRef><TOKEN>$</TOKEN><QName>page</QName></VarRef> <TOKEN>*</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>cons:OPTION</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>cons:K-MAXROWS</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></MultiplicativeExpr>
  <TOKEN>)</TOKEN></ParenthesizedExpr> <TOKEN>else</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <IntegerLiteral>999999999</IntegerLiteral>
  <TOKEN>)</TOKEN></ParenthesizedExpr></IfExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : Chops a string result to the maximum number of allowed characters.
 : @param  $string  string
 : @param  $max     maximum number of characters
 : @return string
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>util:chop</QName><TOKEN>(</TOKEN>
  <ParamList><Param><TOKEN>$</TOKEN><QName>string</QName>  <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>,</TOKEN>
  <Param><TOKEN>$</TOKEN><QName>max</QName>     <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:integer</QName></TypeDeclaration></Param></ParamList>
<TOKEN>)</TOKEN> <EnclosedExpr><TOKEN>{</TOKEN>
  <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><ComparisonExpr><FunctionCall><QName>string-length</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>string</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>&gt;</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>max</QName></VarRef></ComparisonExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <StringConcatExpr><FunctionCall><QName>substring</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>string</QName></VarRef><TOKEN>,</TOKEN> <IntegerLiteral>1</IntegerLiteral><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>max</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>||</TOKEN> <StringLiteral>'...'</StringLiteral></StringConcatExpr>
  <TOKEN>)</TOKEN></ParenthesizedExpr> <TOKEN>else</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
    <VarRef><TOKEN>$</TOKEN><QName>string</QName></VarRef>
  <TOKEN>)</TOKEN></ParenthesizedExpr></IfExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog></LibraryModule>
<EOF/></XQuery>