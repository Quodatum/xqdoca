<XQuery>(:~ 
: create new app
: @author andy bunce
: @since july 2018
:)

(:~ 
 : name of the app to create
 : @default myapp
 :)
<MainModule><Prolog><AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>name</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration>  <TOKEN>external</TOKEN> <TOKEN>:=</TOKEN><StringLiteral>"myapp"</StringLiteral></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~
: generate new app code with given name
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>local:new</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>name</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <QName>xs:base64Binary</QName>
<EnclosedExpr><TOKEN>{</TOKEN>
    <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>archive</QName><TOKEN>:=</TOKEN><FunctionCall><QName>file:read-binary</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>fn:resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'./data/vuetif.zip'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
   <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>contents</QName> <TOKEN>:=</TOKEN> <FunctionCall><QName>archive:extract-binary</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>archive</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
   <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>entries</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>archive:entries</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>archive</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
   (: update paths :)
   <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>entries</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>entries</QName></VarRef><TOKEN>!</TOKEN><FunctionCall><QName>fn:replace</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>,</TOKEN><StringLiteral>'vuetif'</StringLiteral><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></LetBinding></LetClause>
   <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>contents</QName><TOKEN>:=</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>contents</QName></VarRef><TOKEN>!</TOKEN><FunctionCall><QName>local:update-extract</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>,</TOKEN><StringLiteral>'[Vv]uetif'</StringLiteral><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></LetBinding></LetClause>

   <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>archive:create</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>entries</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>contents</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : test for text
 : @see http://stackoverflow.com/questions/2644938/how-to-tell-binary-from-text-files-in-linux
 :) 
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>local:is-text</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>b</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:base64Binary</QName></TypeDeclaration></Param> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <QName>xs:boolean</QName><EnclosedExpr><TOKEN>{</TOKEN>
    <FunctionCall><QName>fn:empty</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>bin:find</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>b</QName></VarRef><TOKEN>,</TOKEN> <IntegerLiteral>0</IntegerLiteral><TOKEN>,</TOKEN><FunctionCall><QName>bin:hex</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"00"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : if context is text replace string else return unchanged
 :) 
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>local:update-extract</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>extract</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:base64Binary</QName></TypeDeclaration></Param><TOKEN>,</TOKEN>
                                <Param><TOKEN>$</TOKEN><QName>from</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>,</TOKEN>
                                <Param><TOKEN>$</TOKEN><TOKEN>to</TOKEN> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param></ParamList> <TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <QName>xs:base64Binary</QName><EnclosedExpr><TOKEN>{</TOKEN>
  <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>local:is-text</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>extract</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN>
  <TOKEN>then</TOKEN> <TryCatchExpr><TryClause><TOKEN>try</TOKEN><EnclosedExpr><TOKEN>{</TOKEN>
  (: escape chars etc :)
    <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>t</QName><TOKEN>:=</TOKEN><FunctionCall><QName>convert:binary-to-string</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>extract</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
    <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>t</QName><TOKEN>:=</TOKEN><FunctionCall><QName>fn:replace</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>t</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>from</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>to</TOKEN></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
    <ReturnClause><TOKEN>return</TOKEN> <FunctionCall><QName>convert:string-to-base64</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>t</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></ReturnClause></FLWORExpr>
    <TOKEN>}</TOKEN></EnclosedExpr></TryClause> <CatchClause><TOKEN>catch</TOKEN> <Wildcard>*</Wildcard> <EnclosedExpr><TOKEN>{</TOKEN>
    <VarRef><TOKEN>$</TOKEN><QName>extract</QName></VarRef>
    <TOKEN>}</TOKEN></EnclosedExpr></CatchClause></TryCatchExpr>
  <TOKEN>else</TOKEN> 
    <VarRef><TOKEN>$</TOKEN><QName>extract</QName></VarRef></IfExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog>
 
<FunctionCall><QName>update:output</QName><ArgumentList><TOKEN>(</TOKEN><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>json</QName><DirAttributeList><S> </S><QName>type</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrContentChar>o</QuotAttrContentChar><QuotAttrContentChar>b</QuotAttrContentChar><QuotAttrContentChar>j</QuotAttrContentChar><QuotAttrContentChar>e</QuotAttrContentChar><QuotAttrContentChar>c</QuotAttrContentChar><QuotAttrContentChar>t</QuotAttrContentChar><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>msg</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><ElementContentChar> </ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef> <TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>.</ElementContentChar><TOKEN>&lt;/</TOKEN><QName>msg</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><TOKEN>&lt;/</TOKEN><QName>json</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MainModule>  <EOF/></XQuery>