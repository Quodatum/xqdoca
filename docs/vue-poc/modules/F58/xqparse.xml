<XQuery><Module><VersionDecl><TOKEN>xquery</TOKEN> <TOKEN>version</TOKEN> <StringLiteral>"3.1"</StringLiteral><TOKEN>;</TOKEN></VersionDecl>
(:~
: dice utils - sort, filter, and serialize as json.
: can read parameters from request: sort,start,limit.
: @requires basex 8.6 for map:merge
: @author andy bunce
: @since mar 2013
:)

<LibraryModule><ModuleDecl><TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>dice</NCName> <TOKEN>=</TOKEN> <StringLiteral>'quodatum.web.dice/v4'</StringLiteral><TOKEN>;</TOKEN></ModuleDecl>

<Prolog><AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>dice:default</QName><TOKEN>:=</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN>
    <MapConstructorEntry><StringLiteral>"start"</StringLiteral> <TOKEN>:</TOKEN> <IntegerLiteral>1</IntegerLiteral></MapConstructorEntry><TOKEN>,</TOKEN> (: start index :)
    <MapConstructorEntry><StringLiteral>"limit"</StringLiteral> <TOKEN>:</TOKEN> <IntegerLiteral>30</IntegerLiteral></MapConstructorEntry><TOKEN>,</TOKEN> (: max items :)
    <MapConstructorEntry><StringLiteral>"sort"</StringLiteral> <TOKEN>:</TOKEN> <StringLiteral>""</StringLiteral></MapConstructorEntry>
<TOKEN>}</TOKEN></MapConstructor></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~ 
 : sort items
 : @param sort  field name to sort on. Optional leading +/-
 : @param $fmap as map(*) field
 : @return sorted items 
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:sort</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>items</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param>
                     <TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>fmap</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param>
                     <TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>sort</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><QName>xs:string</QName><TOKEN>?</TOKEN></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><ItemType><TOKEN>item</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ItemType><TOKEN>*</TOKEN></SequenceType><EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>sort</QName><TOKEN>:=</TOKEN><FunctionCall><QName>fn:normalize-space</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><TOKEN>ascending</TOKEN><TOKEN>:=</TOKEN><FunctionCall><QName>fn:not</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>fn:starts-with</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>"-"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>fld</QName><TOKEN>:=</TOKEN><FunctionCall><QName>fn:substring</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>,</TOKEN><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><ComparisonExpr><FunctionCall><QName>fn:substring</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>sort</QName></VarRef><TOKEN>,</TOKEN><IntegerLiteral>1</IntegerLiteral><TOKEN>,</TOKEN><IntegerLiteral>1</IntegerLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><StringLiteral>"+"</StringLiteral><TOKEN>,</TOKEN><StringLiteral>"-"</StringLiteral></Expr><TOKEN>)</TOKEN></ParenthesizedExpr></ComparisonExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <IntegerLiteral>2</IntegerLiteral> <TOKEN>else</TOKEN> <IntegerLiteral>1</IntegerLiteral></IfExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>fn:not</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>map:contains</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>fmap</QName></VarRef><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>fld</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
            <VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef>
          <TOKEN>else</TOKEN> <IfExpr><TOKEN>if</TOKEN> <TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>ascending</TOKEN></VarRef><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
            <FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>i</QName> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef></ForBinding></ForClause>
           (: let $i:=fn:trace($i,"feld " || $fld ) :)
            <OrderByClause><TOKEN>order</TOKEN> <TOKEN>by</TOKEN> <OrderSpec><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>fmap</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>fld</QName></VarRef><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr> <OrderModifier><TOKEN>ascending</TOKEN> <TOKEN>collation</TOKEN> <StringLiteral>"http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive"</StringLiteral></OrderModifier></OrderSpec></OrderByClause>
            <ReturnClause><TOKEN>return</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef></ReturnClause></FLWORExpr>
          <TOKEN>else</TOKEN>
            <FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>i</QName> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef></ForBinding></ForClause> 
            <OrderByClause><TOKEN>order</TOKEN> <TOKEN>by</TOKEN>  <OrderSpec><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>fmap</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>fld</QName></VarRef><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr> <OrderModifier><TOKEN>descending</TOKEN> <TOKEN>collation</TOKEN> <StringLiteral>"http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive"</StringLiteral></OrderModifier></OrderSpec></OrderByClause>
            <ReturnClause><TOKEN>return</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>i</QName></VarRef></ReturnClause></FLWORExpr></IfExpr></IfExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ generate item xml for all fields in map :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:json-flds</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><TOKEN>item</TOKEN></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>fldmap</QName></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>_</QName><TOKEN>)</TOKEN></ElementTest><EnclosedExpr><TOKEN>{</TOKEN>
  <FunctionCall><QName>dice:json-flds</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>fldmap</QName></VarRef><TOKEN>,</TOKEN><FunctionCall><QName>map:keys</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>fldmap</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ generate item xml for some fields in map :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:json-flds</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><TOKEN>item</TOKEN> <TypeDeclaration><TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ElementTest></TypeDeclaration></Param><TOKEN>,</TOKEN>
                           <Param><TOKEN>$</TOKEN><QName>fldmap</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param><TOKEN>,</TOKEN>
						   <Param><TOKEN>$</TOKEN><QName>keys</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><QName>xs:string</QName><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>_</QName><TOKEN>)</TOKEN></ElementTest><EnclosedExpr><TOKEN>{</TOKEN> 
    <DirElemConstructor><TOKEN>&lt;</TOKEN><QName>_</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><ElementContentChar> </ElementContentChar><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>key</QName> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>keys</QName></VarRef></ForBinding></ForClause> 
	<ReturnClause><TOKEN>return</TOKEN> 
    <TryCatchExpr><TryClause><TOKEN>try</TOKEN><EnclosedExpr><TOKEN>{</TOKEN>
       <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>fldmap</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>key</QName></VarRef><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr>
    <TOKEN>}</TOKEN></EnclosedExpr></TryClause><CatchClause><TOKEN>catch</TOKEN> <Wildcard>*</Wildcard> <EnclosedExpr><TOKEN>{</TOKEN>
       <CompElemConstructor><TOKEN>element</TOKEN> <TOKEN>{</TOKEN><VarRef><TOKEN>$</TOKEN><QName>key</QName></VarRef><TOKEN>}</TOKEN><EnclosedExpr><TOKEN>{</TOKEN><VarRef><TOKEN>$</TOKEN><QName>err:description</QName></VarRef> <TOKEN>}</TOKEN></EnclosedExpr></CompElemConstructor>
    <TOKEN>}</TOKEN></EnclosedExpr></CatchClause></TryCatchExpr></ReturnClause></FLWORExpr> <TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>
</ElementContentChar><ElementContentChar>	</ElementContentChar><TOKEN>&lt;/</TOKEN><QName>_</QName><TOKEN>&gt;</TOKEN></DirElemConstructor>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~ 
 : sort, slice, return json using request parameters
 : @param $items sequence of source items
 : @param $opts sort and slice values
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:response</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>items</QName></Param><TOKEN>,</TOKEN>
                          <Param><TOKEN>$</TOKEN><QName>entity</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param><TOKEN>,</TOKEN>
                          <Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
 <TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>json</QName><TOKEN>)</TOKEN></ElementTest>
 <EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>total</QName><TOKEN>:=</TOKEN><FunctionCall><QName>fn:count</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>opts</QName><TOKEN>:=</TOKEN><FunctionCall><QName>map:merge</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>dice:default</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>items</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>dice:sort</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>access</NCName></Lookup></PostfixExpr><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>sort</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>jsonf</QName><TOKEN>:=</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>json</NCName></Lookup></PostfixExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>fields</QName><TOKEN>:=</TOKEN><IfExpr><TOKEN>if</TOKEN> <TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>fields</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <FunctionCall><QName>fn:tokenize</QName><ArgumentList><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>fields</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>else</TOKEN> <FunctionCall><QName>map:keys</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>jsonf</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></IfExpr></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>slice</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>fn:subsequence</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><TOKEN>start</TOKEN></Lookup></PostfixExpr><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>limit</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> 
  <DirElemConstructor><TOKEN>&lt;</TOKEN><QName>json</QName><DirAttributeList><S> </S><QName>objects</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrContentChar>j</QuotAttrContentChar><QuotAttrContentChar>s</QuotAttrContentChar><QuotAttrContentChar>o</QuotAttrContentChar><QuotAttrContentChar>n</QuotAttrContentChar><QuotAttrContentChar> </QuotAttrContentChar><QuotAttrContentChar>_</QuotAttrContentChar><TOKEN>"</TOKEN></DirAttributeValue><S> </S></DirAttributeList><TOKEN>&gt;</TOKEN><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>total</QName><DirAttributeList><S> </S><QName>type</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrContentChar>n</QuotAttrContentChar><QuotAttrContentChar>u</QuotAttrContentChar><QuotAttrContentChar>m</QuotAttrContentChar><QuotAttrContentChar>b</QuotAttrContentChar><QuotAttrContentChar>e</QuotAttrContentChar><QuotAttrContentChar>r</QuotAttrContentChar><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><EnclosedExpr><TOKEN>{</TOKEN><VarRef><TOKEN>$</TOKEN><QName>total</QName></VarRef><TOKEN>}</TOKEN></EnclosedExpr><TOKEN>&lt;/</TOKEN><QName>total</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>range</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><EnclosedExpr><TOKEN>{</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><TOKEN>start</TOKEN></Lookup></PostfixExpr><TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>-</ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><AdditiveExpr><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><TOKEN>start</TOKEN></Lookup></PostfixExpr><TOKEN>+</TOKEN><FunctionCall><QName>fn:count</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>slice</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>-</TOKEN><IntegerLiteral>1</IntegerLiteral></AdditiveExpr><TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>/</ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><VarRef><TOKEN>$</TOKEN><QName>total</QName></VarRef><TOKEN>}</TOKEN></EnclosedExpr><TOKEN>&lt;/</TOKEN><QName>range</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>entity</QName><DirAttributeList/><TOKEN>&gt;</TOKEN><EnclosedExpr><TOKEN>{</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>name</NCName></Lookup></PostfixExpr><TOKEN>}</TOKEN></EnclosedExpr><TOKEN>&lt;/</TOKEN><QName>entity</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><DirElemConstructor><TOKEN>&lt;</TOKEN><QName>items</QName><DirAttributeList><S> </S><QName>type</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrContentChar>a</QuotAttrContentChar><QuotAttrContentChar>r</QuotAttrContentChar><QuotAttrContentChar>r</QuotAttrContentChar><QuotAttrContentChar>a</QuotAttrContentChar><QuotAttrContentChar>y</QuotAttrContentChar><TOKEN>"</TOKEN></DirAttributeValue></DirAttributeList><TOKEN>&gt;</TOKEN><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><TOKEN>item</TOKEN> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>slice</QName></VarRef></ForBinding></ForClause>
        <ReturnClause><TOKEN>return</TOKEN> <DirElemConstructor><TOKEN>&lt;</TOKEN><QName>_</QName><S> </S><TOKEN>&gt;</TOKEN><EnclosedExpr><TOKEN>{</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>fields</QName></VarRef><TOKEN>!</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>jsonf</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></RelativePathExpr><TOKEN>}</TOKEN></EnclosedExpr><TOKEN>&lt;/</TOKEN><QName>_</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></ReturnClause></FLWORExpr><TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><TOKEN>&lt;/</TOKEN><QName>items</QName><TOKEN>&gt;</TOKEN></DirElemConstructor><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><TOKEN>&lt;/</TOKEN><QName>json</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></ReturnClause></FLWORExpr> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : sort, slice, return json
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:response</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>items</QName></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>entity</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
    <FunctionCall><QName>dice:response</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>items</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : get data for object with key =name
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:get</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>entity</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>name</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></ElementTest><EnclosedExpr><TOKEN>{</TOKEN>
    <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>results</QName><TOKEN>:=</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"data"</StringLiteral><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></LetBinding></LetClause>
    <ReturnClause><TOKEN>return</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>results</QName></VarRef><Predicate><TOKEN>[</TOKEN><ComparisonExpr><VarRef><TOKEN>$</TOKEN><QName>name</QName></VarRef><TOKEN>=</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>access</NCName></Lookup><Lookup><TOKEN>?</TOKEN><NCName>name</NCName></Lookup><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></ComparisonExpr><TOKEN>]</TOKEN></Predicate></PostfixExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>


(:~ 
 : @return  json for item
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:one</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><TOKEN>item</TOKEN></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>entity</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FunctionCall><QName>dice:one</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : @return  json for item
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>dice:one</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><TOKEN>item</TOKEN></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>entity</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <ElementTest><TOKEN>element</TOKEN><TOKEN>(</TOKEN><QName>json</QName><TOKEN>)</TOKEN></ElementTest>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>jsonf</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>map:get</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>entity</QName></VarRef><TOKEN>,</TOKEN><StringLiteral>"json"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>fields</QName><TOKEN>:=</TOKEN><IfExpr><TOKEN>if</TOKEN> <TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>fields</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN> <TOKEN>then</TOKEN> <FunctionCall><QName>fn:tokenize</QName><ArgumentList><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>fields</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>else</TOKEN> <ArrowExpr><FunctionCall><QName>map:keys</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>jsonf</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>=&gt;</TOKEN><QName>fn:trace</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"FF"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></ArrowExpr></IfExpr></LetBinding></LetClause>
  
  <ReturnClause><TOKEN>return</TOKEN>  <DirElemConstructor><TOKEN>&lt;</TOKEN><QName>json</QName><DirAttributeList><S> </S><QName>objects</QName><TOKEN>=</TOKEN><DirAttributeValue><TOKEN>"</TOKEN><QuotAttrContentChar>j</QuotAttrContentChar><QuotAttrContentChar>s</QuotAttrContentChar><QuotAttrContentChar>o</QuotAttrContentChar><QuotAttrContentChar>n</QuotAttrContentChar><QuotAttrContentChar> </QuotAttrContentChar><TOKEN>"</TOKEN></DirAttributeValue><S> </S></DirAttributeList><TOKEN>&gt;</TOKEN><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><EnclosedExpr><TOKEN>{</TOKEN><RelativePathExpr><VarRef><TOKEN>$</TOKEN><QName>fields</QName></VarRef><TOKEN>!</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>jsonf</QName></VarRef><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>)</TOKEN></ArgumentList><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>item</TOKEN></VarRef><TOKEN>)</TOKEN></ArgumentList></PostfixExpr></RelativePathExpr><TOKEN>}</TOKEN></EnclosedExpr><ElementContentChar>
</ElementContentChar><ElementContentChar> </ElementContentChar><ElementContentChar> </ElementContentChar><TOKEN>&lt;/</TOKEN><QName>json</QName><TOKEN>&gt;</TOKEN></DirElemConstructor></ReturnClause></FLWORExpr> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog></LibraryModule></Module>
<EOF/></XQuery>