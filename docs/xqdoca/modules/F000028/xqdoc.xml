<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-05-17T18:35:19.705+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum:xqdoca.page</xqdoc:uri><xqdoc:name>page</xqdoc:name><xqdoc:comment><xqdoc:description><p>html utilities for page generation</p></xqdoc:description><xqdoc:author>Andy Bunce, Quodatum, License: Apache-2.0</xqdoc:author><xqdoc:custom tag="copyright">Copyright (c) 2019-2026 Quodatum Ltd</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version "3.1";&#xD;
(:~&#xD;
&lt;p&gt;html utilities for page generation&lt;/p&gt;&#xD;
@copyright Copyright (c) 2019-2026 Quodatum Ltd&#xD;
@author Andy Bunce, Quodatum, License: Apache-2.0&#xD;
:)&#xD;
 &#xD;
&#xD;
module namespace page = 'quodatum:xqdoca.page';&#xD;
import module namespace xqn = 'quodatum:xqdoca.namespaces' at "xqdoc-namespace.xqm";&#xD;
declare namespace xqdoc="http://www.xqdoc.org/1.0";&#xD;
&#xD;
(:~ prism version path from resources/ :)&#xD;
declare variable $page:prism  as xs:string :="prism/1.29.0/";&#xD;
&#xD;
(:~ make html href-able id :)&#xD;
declare function page:id($id as xs:string)&#xD;
as xs:string&#xD;
{&#xD;
 "ID_" || escape-html-uri($id)&#xD;
};&#xD;
&#xD;
(:~&#xD;
 : generate link to module with namespace, may be multiple &#xD;
 :)&#xD;
 declare function page:link-module($uri as xs:string,  $model as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
 let $files:=$model?files[?namespace=$uri]&#xD;
 let $root:="../../"&#xD;
 return if(empty($files)) then&#xD;
           &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $uri }&lt;/span&gt;&#xD;
        else&#xD;
           &lt;span&gt;&#xD;
           &lt;a href="{ $root }{ $files[1]?href }index.html" title="{ $files[1]?path }"&gt;{ $files[1]?namespace }&lt;/a&gt;&#xD;
           {for $file at $pos in tail($files)&#xD;
           return ("&amp;#160;",&#xD;
                &lt;a  href="{ $root }{ $file?href }index.html" title="{ $file?path }"&gt;&#xD;
                &lt;span class="badge badge-info"&gt;{1+$pos}&lt;/span&gt;&#xD;
                &lt;/a&gt;&#xD;
                )&#xD;
         }&lt;/span&gt; &#xD;
};&#xD;
&#xD;
&#xD;
(:~ link to module :)&#xD;
declare &#xD;
function page:link-module($file as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
   let $desc:=  $file?xqdoc/xqdoc:module/xqdoc:comment/xqdoc:description&#xD;
   return &lt;span&gt;&#xD;
    &lt;a href="{ $file?href }index.html" title="{ page:line-wrap($desc,60) }"&gt;{ $file?namespace }&lt;/a&gt; &#xD;
   &lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~ link to fun or var in file&#xD;
 : @param name of form 'fun#arity or '$name' &#xD;
:)&#xD;
declare &#xD;
function page:link-function($uri as xs:string,&#xD;
                            $name as xs:string,&#xD;
                            $file as map(*),&#xD;
                            $model as map(*))                       &#xD;
as element(span)&#xD;
{  &#xD;
   let $files:= $model?files[?namespace=$uri]&#xD;
   let $clark:= xqn:clark-name($uri,$name)&#xD;
   let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces)&#xD;
   let $root:="../../"&#xD;
   return if(empty($files)) then&#xD;
           &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $clark }&lt;/span&gt;&#xD;
        else&#xD;
           let $file:=head($files)&#xD;
           return &lt;span&gt;&#xD;
            &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &#xD;
           &lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~  link to restxq view&#xD;
 : @todo only if generated&#xD;
 :)&#xD;
declare &#xD;
function page:link-restxq($path as xs:string,&#xD;
                          $method as xs:string,&#xD;
                          $fromModule as xs:boolean&#xD;
                            )                       &#xD;
as element(span)&#xD;
{  &#xD;
 let $root:=if($fromModule) &#xD;
            then "../../" &#xD;
            else ""&#xD;
  return  &lt;span&gt;&lt;a href="{ $root }restxq.html#{ $path}#{ $method }"&gt;{ page:badge-method($method)}&lt;/a&gt;&lt;/span&gt;&#xD;
};&#xD;
 &#xD;
(:~ link to fun or var in file&#xD;
 : @param name of form 'fun#arity' or ''$name' &#xD;
 : @param fromModule where called from&#xD;
:)&#xD;
declare &#xD;
function page:link-function2($uri as xs:string,&#xD;
                             $name as xs:string,&#xD;
                             $file as map(*),&#xD;
                             $fromModule as xs:boolean&#xD;
                           )                       &#xD;
as element(span)&#xD;
{  &#xD;
   let $clark:= xqn:clark-name($uri,$name)&#xD;
   let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces)&#xD;
   let $root:=if($fromModule) then "../../" else ""&#xD;
   return  &lt;span&gt;&#xD;
            &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &#xD;
           &lt;/span&gt;&#xD;
};&#xD;
&#xD;
&#xD;
(: badge for http method :)&#xD;
declare function page:badge-method($method as xs:string)&#xD;
as element(span)&#xD;
{&#xD;
      &lt;span class="badge op-{ lower-case($method) }"&gt;{ $method }&lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~&#xD;
 :  connections 3 column list &#xD;
 :)&#xD;
declare function page:calls($calls-this as item()*, $this, $called-by-this as item()*)&#xD;
as element(div)?&#xD;
{&#xD;
  if(0=count($calls-this) and 0=count($called-by-this))then ()&#xD;
  else &#xD;
      &lt;div style="display: flex; justify-content: space-between; align-items: center;"&gt;&#xD;
        &lt;div style="flex-grow: 1;padding:10px;"&gt;{ if (count($calls-this)) &#xD;
                                  then $calls-this!&lt;div style="text-align: right;" &gt;{.}&lt;/div&gt;&#xD;
                                  else "(None)"   &#xD;
      }&lt;/div&gt;&#xD;
                      &#xD;
     &lt;div style="display: flex; flex-direction: column; justify-content: center; padding:10px; background-color:blanchedalmond;"&gt;&#xD;
         &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt;&#xD;
        &lt;div class="badge badge-info"&gt;{ $this }&lt;/div&gt;&#xD;
        &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt;&#xD;
     &lt;/div&gt;&#xD;
     &#xD;
    &lt;div style="flex-grow: 1;padding:10px;justify-content: space-between;align-items:center;"&gt;&#xD;
    &lt;div style=""&gt;{ if(count($called-by-this)) &#xD;
                              then $called-by-this!&lt;div style="text-align: left;"&gt;{.}&lt;/div&gt;&#xD;
                              else "(None)"&#xD;
     }&lt;/div&gt;&#xD;
     &lt;/div&gt;&#xD;
&lt;/div&gt; &#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : generate standard page wrapper&#xD;
 : uses $opts?resources&#xD;
  :)&#xD;
declare function page:wrap($body,$opts as map(*)) &#xD;
as element(html)&#xD;
{&#xD;
  let $resources:=page:resource-path($opts)&#xD;
  return&#xD;
    &lt;html&gt;&#xD;
      {page:head(  $opts?project || " - xqDocA",$resources)}&#xD;
      &lt;body class="home" id="top"&gt;&#xD;
        &lt;div id="main" class="line-numbers"&gt;&#xD;
        {$body}&#xD;
        &lt;/div&gt;&#xD;
        &lt;div class="footer"&gt;&#xD;
            &lt;p style="text-align:right"&gt;Generated by &#xD;
            &lt;a href="https://github.com/Quodatum/xqdoca" target="_blank"&gt;xqDocA &lt;span&gt;{$opts?xqdoca}&lt;/span&gt;&lt;/a&gt;&#xD;
            &amp;#160; {$opts?version} on { page:date() }&lt;/p&gt;&#xD;
          &lt;/div&gt;&#xD;
         &lt;script  src="{  $resources || $page:prism }prism.js" type="text/javascript"&gt; &lt;/script&gt;&#xD;
        &lt;script  src="{ $resources }xqdoca.js" type="text/javascript"&gt; &lt;/script&gt;&#xD;
      &lt;/body&gt;&#xD;
    &lt;/html&gt;&#xD;
};&#xD;
&#xD;
(:~ common html head&#xD;
@param resources relative path to resources&#xD;
 :)&#xD;
declare function page:head($title as xs:string,$resources as xs:string)&#xD;
as element(head){&#xD;
     &lt;head&gt;&#xD;
       &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&#xD;
       &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/&gt; &#xD;
       &lt;meta http-equiv="Generator" content="xqdoca - https://github.com/quodatum/xqdoca" /&gt;&#xD;
        &lt;title&gt;{ $title } - xqDocA&lt;/title&gt;&#xD;
        &#xD;
        &lt;link rel="shortcut icon" type="image/x-icon" href="{ $resources }xqdoc.png" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources || $page:prism }prism.css"/&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }page.css" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }query.css" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }base.css" /&gt;   &#xD;
      &lt;/head&gt;&#xD;
};&#xD;
&#xD;
declare function page:resource-path($opts as map(*))&#xD;
as xs:string&#xD;
{&#xD;
  if(map:contains($opts,"resources")) then $opts?resources else  "resources/"&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : build toc &#xD;
 : @param $name title&#xD;
 : @param $tree xml &#xD;
 : @param $decorate function called on leafs&#xD;
 :)&#xD;
declare function page:toc3($head as item(),&#xD;
$tree as element(directory),&#xD;
$decorate as function(*))&#xD;
as element(nav)&#xD;
{&#xD;
    &lt;nav id="toc"&gt;&#xD;
            &lt;h2&gt;&#xD;
             &lt;a href="../"&gt;^&lt;/a&gt;      &#xD;
                &lt;a id="contents"&gt;&lt;/a&gt;              &#xD;
                   { $head }&#xD;
            &lt;/h2&gt;&#xD;
            &lt;ol class="toc"&gt;{&#xD;
             $tree/*! page:tree-list(.,position(),$decorate,99)&#xD;
          }&lt;/ol&gt;&#xD;
        &lt;/nav&gt; &#xD;
};&#xD;
&#xD;
(:~  section numbering util return dotted string :)&#xD;
declare function page:section($pos as xs:anyAtomicType*)&#xD;
as xs:string{&#xD;
  string-join($pos,".") || "&amp;#160;"&#xD;
};&#xD;
&#xD;
(:~ toc from sections&#xD;
 : @param $head title&#xD;
 : @param $section elements to toc&#xD;
:)&#xD;
declare function page:toc($head,$sections as element(section)*,$links)&#xD;
as element(nav)&#xD;
{&#xD;
 &lt;nav id="toc"&gt;&#xD;
            &lt;h2 class="h3 d-inline-block"&gt;&#xD;
                &lt;a href="../index.html" class="mr-5 bg-info"&gt;↖&lt;/a&gt;&#xD;
                &lt;a id="contents"&gt;&lt;/a&gt;              &#xD;
                   { $head }&#xD;
            &lt;/h2&gt;&#xD;
            {$links}&#xD;
            &lt;ol class="toc"&gt;{&#xD;
			$sections!page:section-toc(.,position())&#xD;
			}&lt;/ol&gt;&#xD;
&lt;/nav&gt;&#xD;
};&#xD;
&#xD;
declare function page:section-toc($section as element(section),$pos as xs:integer*)&#xD;
as element(li)&#xD;
{&#xD;
&lt;li&gt;&#xD;
      &lt;a href="#{ $section/@id/string() }"&gt;&#xD;
           &lt;span class="secno"&gt;{ string-join($pos,".") }&lt;/span&gt;&#xD;
           &lt;span class="content"&gt;{ $section/*[1]/(*|text()) }&lt;/span&gt;&#xD;
      &lt;/a&gt;&#xD;
      { let $more:= outermost($section//section)&#xD;
        return if($more) then&#xD;
           &lt;ol&gt;{$more!page:section-toc(.,($pos,position()))}&lt;/ol&gt;&#xD;
           else ()&#xD;
       }   &#xD;
&lt;/li&gt;&#xD;
};&#xD;
&#xD;
(:~ tree to list&#xD;
 : @param tree file (@name.@target) directory elements &#xD;
 : @param $seq  section number as sequence of levels&#xD;
:)&#xD;
declare function page:tree-list($tree as element(*),&#xD;
                                $seq as xs:integer*,&#xD;
                                $render as function(*),&#xD;
                                $maxdepth as xs:integer)&#xD;
as element(li){&#xD;
  let $pos:=page:section($seq)&#xD;
  &#xD;
  return &lt;li&gt;{&#xD;
         $render($pos,$tree),&#xD;
         if($tree  instance of element(directory) and $maxdepth &gt; 0)then&#xD;
          &lt;ol &gt;{ $tree/*!page:tree-list(.,($seq,position()),$render,$maxdepth -1 ) }&lt;/ol&gt;&#xD;
          else ()&#xD;
        }&lt;/li&gt;&#xD;
 &#xD;
};&#xD;
&#xD;
declare function page:tree-list2($tree as element(*),&#xD;
                                $seq as xs:integer*,&#xD;
                                $render as function(*),&#xD;
                                $maxdepth as xs:integer)&#xD;
as element(li){&#xD;
  let $pos:=page:section($seq)&#xD;
  let $isNested:=$tree instance of element(directory) and $maxdepth &gt; 0&#xD;
  return &lt;li&gt;{&#xD;
         (if($isNested)&#xD;
          &#xD;
          then &#xD;
            &lt;span class="caret"&gt;&#xD;
            {$render($pos,$tree)}/&#xD;
            &lt;/span&gt;&#xD;
            &#xD;
          else $render($pos,$tree),&#xD;
     &#xD;
         if($isNested) &#xD;
         then &#xD;
             &lt;ul class="nested"&gt;{ &#xD;
             $tree/*!page:tree-list2(.,($seq,position()),$render,$maxdepth -1 ) &#xD;
             }&lt;/ul&gt;&#xD;
              &#xD;
          else ()&#xD;
        )}&lt;/li&gt;&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : simple toc render &#xD;
 : @see tree-list&#xD;
 :)&#xD;
declare function page:toc-render($pos as xs:string,$el as element(*))&#xD;
as element(*)&#xD;
{&#xD;
let $c:=(&#xD;
&lt;span class="secno"&gt;{$pos}&lt;/span&gt;,&#xD;
&lt;span class="content"&gt;{$el/@name/string()}&lt;/span&gt;&#xD;
)&#xD;
return if($el/@target) then&#xD;
 &lt;a href="{$el/@target}"&gt;{ $c }&lt;/a&gt;&#xD;
else&#xD;
 &lt;span&gt;{$c}&lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~ formated datetime&#xD;
 : @param $when date to now&#xD;
 :)&#xD;
declare function page:date($when as xs:dateTime)&#xD;
as element(span)&#xD;
{&#xD;
  &lt;span title="{ $when }" &gt;{ format-dateTime($when, "[FNn], [D1o] [MNn] [Y0000]") }&lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~ formated datetime for now :)&#xD;
declare function page:date()&#xD;
as element(span)&#xD;
{&#xD;
 page:date(current-dateTime())&#xD;
};&#xD;
&#xD;
(:~ active renderer names :)&#xD;
declare &#xD;
function page:active-renderers($type as xs:string,&#xD;
                        $opts as map(*),&#xD;
                        $exclude as xs:string*)&#xD;
as xs:string*{&#xD;
let $selected:=$opts?outputs?($type)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return page:tokens($selected)[not(. = $exclude)]&#xD;
};&#xD;
&#xD;
(:~ buttons of renderers&#xD;
 : @param type global or module&#xD;
 : @param exclude list of renderers to omit&#xD;
 :)&#xD;
declare &#xD;
function page:related-buttons($type as xs:string,&#xD;
                        $exclude as xs:string*,&#xD;
                         $opts as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
let $list:=page:active-renderers($type,$opts,$exclude)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return &lt;span class="ml-2"&gt; {&#xD;
      for  $name in $list &#xD;
      let $rend :=  $renderers[?name=$name]&#xD;
      for $def in  $rend&#xD;
      order by $def?name&#xD;
      return page:alink($def)&#xD;
}&lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~ link to render output :)&#xD;
declare function page:alink($def as map(*))&#xD;
as element(a){&#xD;
  let $target:=if($def?output = ("xml","text")) then "_blank" else "_self"&#xD;
  return &lt;a href="{ $def?uri }" title="{ page:line-wrap($def?description,60) }" &#xD;
        class="badge badge-pill badge-light"  style="margin-left:1em"&gt;{ &#xD;
                      attribute target { $target},&#xD;
                      $def?name }&lt;/a&gt;&#xD;
};&#xD;
&#xD;
(:~ table of renderers&#xD;
 : @param type global or module&#xD;
 : @param exclude list of renderers to omit&#xD;
 :)&#xD;
declare &#xD;
function page:related-docs($type as xs:string,&#xD;
                        $opts as map(*),&#xD;
                        $exclude as xs:string*)                       &#xD;
as element(table)?&#xD;
{&#xD;
 let $list:=page:active-renderers($type,$opts,$exclude)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return if(not(empty($list))) then&#xD;
           &lt;table class="data"&gt;&#xD;
                 &lt;thead&gt;&#xD;
                 &lt;th&gt;View&lt;/th&gt;&#xD;
                 &lt;th&gt;Description&lt;/th&gt;&#xD;
                 &lt;th&gt;Format&lt;/th&gt;&#xD;
                 &lt;/thead&gt;&#xD;
                 &lt;tbody&gt;&#xD;
                 {&#xD;
                  for  $name in $list &#xD;
                  let $rend :=  $renderers[?name=$name]&#xD;
&#xD;
                  return (for $def in  $rend&#xD;
                         order by $def?name&#xD;
                         return &lt;tr&gt;&#xD;
                                 &lt;td&gt;{page:alink($def)}&lt;/td&gt;&#xD;
                                  &lt;td&gt;{ $def?description }&lt;/td&gt;&#xD;
                                  &lt;td&gt;{ $def?output }&lt;/td&gt;&#xD;
                                 &lt;/tr&gt;,&#xD;
                         if(empty($rend)) &#xD;
                         then &lt;tr&gt;&#xD;
                                &lt;td&gt;&lt;span class="badge badge-danger"&gt;{ $name }&lt;/span&gt;&lt;/td&gt;&#xD;
                                &lt;td&gt;No renderer found&lt;/td&gt;&#xD;
                               &lt;/tr&gt;&#xD;
                         else ()  &#xD;
                             )&#xD;
                  }    &#xD;
                 &lt;/tbody&gt;&#xD;
        &lt;/table&gt;&#xD;
       else&#xD;
         ()&#xD;
};&#xD;
&#xD;
(:~ related docs details &#xD;
 : @param $type "global" or "module"&#xD;
:)&#xD;
declare function page:related-links($type as xs:string, $exclude as xs:string, $opts as map(*))&#xD;
as element(details)?&#xD;
{&#xD;
let $t:=page:related-docs($type, $opts,$exclude)&#xD;
return if ($t) then&#xD;
         &lt;details&gt;&#xD;
            &lt;summary&gt;Related documents&lt;/summary&gt;&#xD;
            {$t}&#xD;
          &lt;/details&gt;&#xD;
        else&#xD;
           ()&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : Coloured &lt;span/&gt; as bootstrap badge&#xD;
 :)&#xD;
declare function page:badge($label as xs:string,$color as xs:string,$title as xs:string)&#xD;
as element(span)&#xD;
{&#xD;
  &lt;span class="badge badge-{$color}" title="{ $title }"&gt;{$label}&lt;/span&gt;&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 :true() if $url represents a url&#xD;
 :@see http://urlregex.com/ &#xD;
 :)&#xD;
declare function page:is-url($url as xs:string)&#xD;
as xs:boolean&#xD;
{&#xD;
  matches($url,"^(https?|ftp|file)://[-a-zA-Z0-9+&amp;amp;@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&amp;amp;@#/%=~_|]","j")&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : parse tokens from comma space delimited string&#xD;
 :)&#xD;
 declare function page:tokens($s as xs:string)&#xD;
 as xs:string*&#xD;
 {&#xD;
 $s=&gt;normalize-space()=&gt;tokenize("[\s,]+") &#xD;
};&#xD;
&#xD;
(:~ extract comment for name :) &#xD;
declare function page:comment-for($name as xs:string,$v as element(xqdoc:parameters))&#xD;
as xs:string*&#xD;
{&#xD;
 for $comment in $v/../xqdoc:comment/xqdoc:param[&#xD;
                                       starts-with(normalize-space(.), $name) or &#xD;
                                       starts-with(normalize-space(.), concat('$',$name))&#xD;
                                     ]&#xD;
 return substring-after(normalize-space($comment), $name)  &#xD;
};&#xD;
&#xD;
(:~ line count :) &#xD;
declare function page:line-count($txt as xs:string?)&#xD;
as xs:integer{&#xD;
  tokenize($txt, '(\r\n?|\n\r?)')=&gt;count()&#xD;
};&#xD;
&#xD;
(:~ break lines longer than width by inserting newline chars&#xD;
:)&#xD;
declare function page:line-wrap($string as xs:string?,$width as xs:integer)&#xD;
as xs:string?{&#xD;
  $string=&gt;normalize-space()=&gt;concat(" ")=&gt;replace(``[(.{0,`{ $width }`})&#xD;
]``,'$1&amp;#xA;')&#xD;
};</xqdoc:body></xqdoc:module><xqdoc:imports><xqdoc:import type="library"><xqdoc:uri>quodatum:xqdoca.namespaces</xqdoc:uri><xqdoc:at>xqdoc-namespace.xqm</xqdoc:at></xqdoc:import></xqdoc:imports><xqdoc:namespaces><xqdoc:namespace prefix="page" uri="quodatum:xqdoca.page"/><xqdoc:namespace prefix="xqn" uri="quodatum:xqdoca.namespaces"/><xqdoc:namespace prefix="xqdoc" uri="http://www.xqdoc.org/1.0"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/></xqdoc:namespaces><xqdoc:variables><xqdoc:variable><xqdoc:name>page:prism</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
prism version path from resources/</xqdoc:description></xqdoc:comment><xqdoc:type>xs:string</xqdoc:type><xqdoc:body>variable $page:prism  as xs:string :="prism/1.29.0/"</xqdoc:body></xqdoc:variable></xqdoc:variables><xqdoc:functions><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
make html href-able id</xqdoc:description></xqdoc:comment><xqdoc:name>page:id</xqdoc:name><xqdoc:signature>function page:id ( $id as xs:string ) as xs:string { "ID_" || escape-html-uri($id) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>id</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:id($id as xs:string)&#xD;
as xs:string&#xD;
{&#xD;
 "ID_" || escape-html-uri($id)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
generate link to module with namespace, may be multiple&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>page:link-module</xqdoc:name><xqdoc:signature>function page:link-module ( $uri as xs:string, $model as map(*) ) as element(span) { let $files:=$model?files[?namespace=$uri] let $root:="../../" return if(empty($files)) then &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $uri }&lt;/span&gt; else &lt;span&gt; &lt;a href="{ $root }{ $files[1]?href }index.html" title="{ $files[1]?path }"&gt;{ $files[1]?namespace }&lt;/a&gt; {for $file at $pos in tail($files) return ("&amp;#160;", &lt;a href="{ $root }{ $file?href }index.html" title="{ $file?path }"&gt; &lt;span class="badge badge-info"&gt;{1+$pos}&lt;/span&gt; &lt;/a&gt; ) }&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>model</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:link-module($uri as xs:string,  $model as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
 let $files:=$model?files[?namespace=$uri]&#xD;
 let $root:="../../"&#xD;
 return if(empty($files)) then&#xD;
           &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $uri }&lt;/span&gt;&#xD;
        else&#xD;
           &lt;span&gt;&#xD;
           &lt;a href="{ $root }{ $files[1]?href }index.html" title="{ $files[1]?path }"&gt;{ $files[1]?namespace }&lt;/a&gt;&#xD;
           {for $file at $pos in tail($files)&#xD;
           return ("&amp;#160;",&#xD;
                &lt;a  href="{ $root }{ $file?href }index.html" title="{ $file?path }"&gt;&#xD;
                &lt;span class="badge badge-info"&gt;{1+$pos}&lt;/span&gt;&#xD;
                &lt;/a&gt;&#xD;
                )&#xD;
         }&lt;/span&gt; &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
link to module</xqdoc:description></xqdoc:comment><xqdoc:name>page:link-module</xqdoc:name><xqdoc:signature>function page:link-module ( $file as map(*) ) as element(span) { let $desc:= $file?xqdoc/xqdoc:module/xqdoc:comment/xqdoc:description return &lt;span&gt; &lt;a href="{ $file?href }index.html" title="{ page:line-wrap($desc,60) }"&gt;{ $file?namespace }&lt;/a&gt; &lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>file</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:link-module($file as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
   let $desc:=  $file?xqdoc/xqdoc:module/xqdoc:comment/xqdoc:description&#xD;
   return &lt;span&gt;&#xD;
    &lt;a href="{ $file?href }index.html" title="{ page:line-wrap($desc,60) }"&gt;{ $file?namespace }&lt;/a&gt; &#xD;
   &lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="4"><xqdoc:comment><xqdoc:description>&#xD;
link to fun or var in file&#xD;
</xqdoc:description><xqdoc:param>name of form 'fun#arity or '$name'</xqdoc:param></xqdoc:comment><xqdoc:name>page:link-function</xqdoc:name><xqdoc:signature>function page:link-function ( $uri as xs:string, $name as xs:string, $file as map(*), $model as map(*) ) as element(span) { let $files:= $model?files[?namespace=$uri] let $clark:= xqn:clark-name($uri,$name) let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces) let $root:="../../" return if(empty($files)) then &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $clark }&lt;/span&gt; else let $file:=head($files) return &lt;span&gt; &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>file</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>model</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:link-function($uri as xs:string,&#xD;
                            $name as xs:string,&#xD;
                            $file as map(*),&#xD;
                            $model as map(*))                       &#xD;
as element(span)&#xD;
{  &#xD;
   let $files:= $model?files[?namespace=$uri]&#xD;
   let $clark:= xqn:clark-name($uri,$name)&#xD;
   let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces)&#xD;
   let $root:="../../"&#xD;
   return if(empty($files)) then&#xD;
           &lt;span class="badge badge-warning" title="Externally defined"&gt;{ $clark }&lt;/span&gt;&#xD;
        else&#xD;
           let $file:=head($files)&#xD;
           return &lt;span&gt;&#xD;
            &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &#xD;
           &lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
link to restxq view&#xD;
</xqdoc:description><xqdoc:custom tag="todo">only if generated</xqdoc:custom></xqdoc:comment><xqdoc:name>page:link-restxq</xqdoc:name><xqdoc:signature>function page:link-restxq ( $path as xs:string, $method as xs:string, $fromModule as xs:boolean ) as element(span) { let $root:=if($fromModule) then "../../" else "" return &lt;span&gt;&lt;a href="{ $root }restxq.html#{ $path}#{ $method }"&gt;{ page:badge-method($method)}&lt;/a&gt;&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>path</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>method</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>fromModule</xqdoc:name><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:link-restxq($path as xs:string,&#xD;
                          $method as xs:string,&#xD;
                          $fromModule as xs:boolean&#xD;
                            )                       &#xD;
as element(span)&#xD;
{  &#xD;
 let $root:=if($fromModule) &#xD;
            then "../../" &#xD;
            else ""&#xD;
  return  &lt;span&gt;&lt;a href="{ $root }restxq.html#{ $path}#{ $method }"&gt;{ page:badge-method($method)}&lt;/a&gt;&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="4"><xqdoc:comment><xqdoc:description>&#xD;
link to fun or var in file&#xD;
</xqdoc:description><xqdoc:param>name of form 'fun#arity' or ''$name'</xqdoc:param><xqdoc:param>fromModule where called from</xqdoc:param></xqdoc:comment><xqdoc:name>page:link-function2</xqdoc:name><xqdoc:signature>function page:link-function2 ( $uri as xs:string, $name as xs:string, $file as map(*), $fromModule as xs:boolean ) as element(span) { let $clark:= xqn:clark-name($uri,$name) let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces) let $root:=if($fromModule) then "../../" else "" return &lt;span&gt; &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>file</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>fromModule</xqdoc:name><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:link-function2($uri as xs:string,&#xD;
                             $name as xs:string,&#xD;
                             $file as map(*),&#xD;
                             $fromModule as xs:boolean&#xD;
                           )                       &#xD;
as element(span)&#xD;
{  &#xD;
   let $clark:= xqn:clark-name($uri,$name)&#xD;
   let $pname:= xqn:prefixed-name($uri,$name,$file?namespaces)&#xD;
   let $root:=if($fromModule) then "../../" else ""&#xD;
   return  &lt;span&gt;&#xD;
            &lt;a href="{ $root }{ $file?href }index.html#{ $clark }" title="{ $file?path }"&gt;{ $pname }&lt;/a&gt; &#xD;
           &lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>page:badge-method</xqdoc:name><xqdoc:signature>function page:badge-method ( $method as xs:string ) as element(span) { &lt;span class="badge op-{ lower-case($method) }"&gt;{ $method }&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>method</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:badge-method($method as xs:string)&#xD;
as element(span)&#xD;
{&#xD;
      &lt;span class="badge op-{ lower-case($method) }"&gt;{ $method }&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
connections 3 column list&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>page:calls</xqdoc:name><xqdoc:signature>function page:calls ( $calls-this as item()*, $this, $called-by-this as item()* ) as element(div)? { if(0=count($calls-this) and 0=count($called-by-this))then () else &lt;div style="display: flex; justify-content: space-between; align-items: center;"&gt; &lt;div style="flex-grow: 1;padding:10px;"&gt;{ if (count($calls-this)) then $calls-this!&lt;div style="text-align: right;" &gt;{.}&lt;/div&gt; else "(None)" }&lt;/div&gt; &lt;div style="display: flex; flex-direction: column; justify-content: center; padding:10px; background-color:blanchedalmond;"&gt; &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt; &lt;div class="badge badge-info"&gt;{ $this }&lt;/div&gt; &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt; &lt;/div&gt; &lt;div style="flex-grow: 1;padding:10px;justify-content: space-between;align-items:center;"&gt; &lt;div style=""&gt;{ if(count($called-by-this)) then $called-by-this!&lt;div style="text-align: left;"&gt;{.}&lt;/div&gt; else "(None)" }&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>calls-this</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>this</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>called-by-this</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">element(div)</xqdoc:type></xqdoc:return><xqdoc:body>function page:calls($calls-this as item()*, $this, $called-by-this as item()*)&#xD;
as element(div)?&#xD;
{&#xD;
  if(0=count($calls-this) and 0=count($called-by-this))then ()&#xD;
  else &#xD;
      &lt;div style="display: flex; justify-content: space-between; align-items: center;"&gt;&#xD;
        &lt;div style="flex-grow: 1;padding:10px;"&gt;{ if (count($calls-this)) &#xD;
                                  then $calls-this!&lt;div style="text-align: right;" &gt;{.}&lt;/div&gt;&#xD;
                                  else "(None)"   &#xD;
      }&lt;/div&gt;&#xD;
                      &#xD;
     &lt;div style="display: flex; flex-direction: column; justify-content: center; padding:10px; background-color:blanchedalmond;"&gt;&#xD;
         &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt;&#xD;
        &lt;div class="badge badge-info"&gt;{ $this }&lt;/div&gt;&#xD;
        &lt;div&gt;&lt;div&gt;imports&lt;/div&gt;&amp;#x2192;&lt;/div&gt;&#xD;
     &lt;/div&gt;&#xD;
     &#xD;
    &lt;div style="flex-grow: 1;padding:10px;justify-content: space-between;align-items:center;"&gt;&#xD;
    &lt;div style=""&gt;{ if(count($called-by-this)) &#xD;
                              then $called-by-this!&lt;div style="text-align: left;"&gt;{.}&lt;/div&gt;&#xD;
                              else "(None)"&#xD;
     }&lt;/div&gt;&#xD;
     &lt;/div&gt;&#xD;
&lt;/div&gt; &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
generate standard page wrapper&#xD;
uses $opts?resources&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>page:wrap</xqdoc:name><xqdoc:signature>function page:wrap ( $body,$opts as map(*) ) as element(html) { let $resources:=page:resource-path($opts) return &lt;html&gt; {page:head( $opts?project || " - xqDocA",$resources)} &lt;body class="home" id="top"&gt; &lt;div id="main" class="line-numbers"&gt; {$body} &lt;/div&gt; &lt;div class="footer"&gt; &lt;p style="text-align:right"&gt;Generated by &lt;a href="https://github.com/Quodatum/xqdoca" target="_blank"&gt;xqDocA &lt;span&gt;{$opts?xqdoca}&lt;/span&gt;&lt;/a&gt; &amp;#160; {$opts?version} on { page:date() }&lt;/p&gt; &lt;/div&gt; &lt;script src="{ $resources || $page:prism }prism.js" type="text/javascript"&gt; &lt;/script&gt; &lt;script src="{ $resources }xqdoca.js" type="text/javascript"&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>body</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(html)</xqdoc:type></xqdoc:return><xqdoc:body>function page:wrap($body,$opts as map(*)) &#xD;
as element(html)&#xD;
{&#xD;
  let $resources:=page:resource-path($opts)&#xD;
  return&#xD;
    &lt;html&gt;&#xD;
      {page:head(  $opts?project || " - xqDocA",$resources)}&#xD;
      &lt;body class="home" id="top"&gt;&#xD;
        &lt;div id="main" class="line-numbers"&gt;&#xD;
        {$body}&#xD;
        &lt;/div&gt;&#xD;
        &lt;div class="footer"&gt;&#xD;
            &lt;p style="text-align:right"&gt;Generated by &#xD;
            &lt;a href="https://github.com/Quodatum/xqdoca" target="_blank"&gt;xqDocA &lt;span&gt;{$opts?xqdoca}&lt;/span&gt;&lt;/a&gt;&#xD;
            &amp;#160; {$opts?version} on { page:date() }&lt;/p&gt;&#xD;
          &lt;/div&gt;&#xD;
         &lt;script  src="{  $resources || $page:prism }prism.js" type="text/javascript"&gt; &lt;/script&gt;&#xD;
        &lt;script  src="{ $resources }xqdoca.js" type="text/javascript"&gt; &lt;/script&gt;&#xD;
      &lt;/body&gt;&#xD;
    &lt;/html&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
common html head&#xD;
</xqdoc:description><xqdoc:param>resources relative path to resources</xqdoc:param></xqdoc:comment><xqdoc:name>page:head</xqdoc:name><xqdoc:signature>function page:head ( $title as xs:string,$resources as xs:string ) as element(head) { &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/&gt; &lt;meta http-equiv="Generator" content="xqdoca - https://github.com/quodatum/xqdoca" /&gt; &lt;title&gt;{ $title } - xqDocA&lt;/title&gt; &lt;link rel="shortcut icon" type="image/x-icon" href="{ $resources }xqdoc.png" /&gt; &lt;link rel="stylesheet" type="text/css" href="{ $resources || $page:prism }prism.css"/&gt; &lt;link rel="stylesheet" type="text/css" href="{ $resources }page.css" /&gt; &lt;link rel="stylesheet" type="text/css" href="{ $resources }query.css" /&gt; &lt;link rel="stylesheet" type="text/css" href="{ $resources }base.css" /&gt; &lt;/head&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>title</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>resources</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(head)</xqdoc:type></xqdoc:return><xqdoc:body>function page:head($title as xs:string,$resources as xs:string)&#xD;
as element(head){&#xD;
     &lt;head&gt;&#xD;
       &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt;&#xD;
       &lt;meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/&gt; &#xD;
       &lt;meta http-equiv="Generator" content="xqdoca - https://github.com/quodatum/xqdoca" /&gt;&#xD;
        &lt;title&gt;{ $title } - xqDocA&lt;/title&gt;&#xD;
        &#xD;
        &lt;link rel="shortcut icon" type="image/x-icon" href="{ $resources }xqdoc.png" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources || $page:prism }prism.css"/&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }page.css" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }query.css" /&gt;&#xD;
        &lt;link rel="stylesheet" type="text/css" href="{ $resources }base.css" /&gt;   &#xD;
      &lt;/head&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:name>page:resource-path</xqdoc:name><xqdoc:signature>function page:resource-path ( $opts as map(*) ) as xs:string { if(map:contains($opts,"resources")) then $opts?resources else "resources/" }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:resource-path($opts as map(*))&#xD;
as xs:string&#xD;
{&#xD;
  if(map:contains($opts,"resources")) then $opts?resources else  "resources/"&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
build toc&#xD;
</xqdoc:description><xqdoc:param>$name title</xqdoc:param><xqdoc:param>$tree xml</xqdoc:param><xqdoc:param>$decorate function called on leafs</xqdoc:param></xqdoc:comment><xqdoc:name>page:toc3</xqdoc:name><xqdoc:signature>function page:toc3 ( $head as item(), $tree as element(directory), $decorate as function(*) ) as element(nav) { &lt;nav id="toc"&gt; &lt;h2&gt; &lt;a href="../"&gt;^&lt;/a&gt; &lt;a id="contents"&gt;&lt;/a&gt; { $head } &lt;/h2&gt; &lt;ol class="toc"&gt;{ $tree/*! page:tree-list(.,position(),$decorate,99) }&lt;/ol&gt; &lt;/nav&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>head</xqdoc:name><xqdoc:type>item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>tree</xqdoc:name><xqdoc:type>element(directory)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>decorate</xqdoc:name><xqdoc:type>function(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(nav)</xqdoc:type></xqdoc:return><xqdoc:body>function page:toc3($head as item(),&#xD;
$tree as element(directory),&#xD;
$decorate as function(*))&#xD;
as element(nav)&#xD;
{&#xD;
    &lt;nav id="toc"&gt;&#xD;
            &lt;h2&gt;&#xD;
             &lt;a href="../"&gt;^&lt;/a&gt;      &#xD;
                &lt;a id="contents"&gt;&lt;/a&gt;              &#xD;
                   { $head }&#xD;
            &lt;/h2&gt;&#xD;
            &lt;ol class="toc"&gt;{&#xD;
             $tree/*! page:tree-list(.,position(),$decorate,99)&#xD;
          }&lt;/ol&gt;&#xD;
        &lt;/nav&gt; &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
section numbering util return dotted string</xqdoc:description></xqdoc:comment><xqdoc:name>page:section</xqdoc:name><xqdoc:signature>function page:section ( $pos as xs:anyAtomicType* ) as xs:string { string-join($pos,".") || "&amp;#160;" }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pos</xqdoc:name><xqdoc:type occurrence="*">xs:anyAtomicType</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:section($pos as xs:anyAtomicType*)&#xD;
as xs:string{&#xD;
  string-join($pos,".") || "&amp;#160;"&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
toc from sections&#xD;
</xqdoc:description><xqdoc:param>$head title</xqdoc:param><xqdoc:param>$section elements to toc</xqdoc:param></xqdoc:comment><xqdoc:name>page:toc</xqdoc:name><xqdoc:signature>function page:toc ( $head,$sections as element(section)*,$links ) as element(nav) { &lt;nav id="toc"&gt; &lt;h2 class="h3 d-inline-block"&gt; &lt;a href="../index.html" class="mr-5 bg-info"&gt;↖&lt;/a&gt; &lt;a id="contents"&gt;&lt;/a&gt; { $head } &lt;/h2&gt; {$links} &lt;ol class="toc"&gt;{ $sections!page:section-toc(.,position()) }&lt;/ol&gt; &lt;/nav&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>head</xqdoc:name></xqdoc:parameter><xqdoc:parameter><xqdoc:name>sections</xqdoc:name><xqdoc:type occurrence="*">element(section)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>links</xqdoc:name></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(nav)</xqdoc:type></xqdoc:return><xqdoc:body>function page:toc($head,$sections as element(section)*,$links)&#xD;
as element(nav)&#xD;
{&#xD;
 &lt;nav id="toc"&gt;&#xD;
            &lt;h2 class="h3 d-inline-block"&gt;&#xD;
                &lt;a href="../index.html" class="mr-5 bg-info"&gt;↖&lt;/a&gt;&#xD;
                &lt;a id="contents"&gt;&lt;/a&gt;              &#xD;
                   { $head }&#xD;
            &lt;/h2&gt;&#xD;
            {$links}&#xD;
            &lt;ol class="toc"&gt;{&#xD;
			$sections!page:section-toc(.,position())&#xD;
			}&lt;/ol&gt;&#xD;
&lt;/nav&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:name>page:section-toc</xqdoc:name><xqdoc:signature>function page:section-toc ( $section as element(section),$pos as xs:integer* ) as element(li) { &lt;li&gt; &lt;a href="#{ $section/@id/string() }"&gt; &lt;span class="secno"&gt;{ string-join($pos,".") }&lt;/span&gt; &lt;span class="content"&gt;{ $section/*[1]/(*|text()) }&lt;/span&gt; &lt;/a&gt; { let $more:= outermost($section//section) return if($more) then &lt;ol&gt;{$more!page:section-toc(.,($pos,position()))}&lt;/ol&gt; else () } &lt;/li&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>section</xqdoc:name><xqdoc:type>element(section)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>pos</xqdoc:name><xqdoc:type occurrence="*">xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(li)</xqdoc:type></xqdoc:return><xqdoc:body>function page:section-toc($section as element(section),$pos as xs:integer*)&#xD;
as element(li)&#xD;
{&#xD;
&lt;li&gt;&#xD;
      &lt;a href="#{ $section/@id/string() }"&gt;&#xD;
           &lt;span class="secno"&gt;{ string-join($pos,".") }&lt;/span&gt;&#xD;
           &lt;span class="content"&gt;{ $section/*[1]/(*|text()) }&lt;/span&gt;&#xD;
      &lt;/a&gt;&#xD;
      { let $more:= outermost($section//section)&#xD;
        return if($more) then&#xD;
           &lt;ol&gt;{$more!page:section-toc(.,($pos,position()))}&lt;/ol&gt;&#xD;
           else ()&#xD;
       }   &#xD;
&lt;/li&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="4"><xqdoc:comment><xqdoc:description>&#xD;
tree to list&#xD;
</xqdoc:description><xqdoc:param>tree file (@name.@target) directory elements</xqdoc:param><xqdoc:param>$seq  section number as sequence of levels</xqdoc:param></xqdoc:comment><xqdoc:name>page:tree-list</xqdoc:name><xqdoc:signature>function page:tree-list ( $tree as element(*), $seq as xs:integer*, $render as function(*), $maxdepth as xs:integer ) as element(li) { let $pos:=page:section($seq) return &lt;li&gt;{ $render($pos,$tree), if($tree instance of element(directory) and $maxdepth &gt; 0)then &lt;ol &gt;{ $tree/*!page:tree-list(.,($seq,position()),$render,$maxdepth -1 ) }&lt;/ol&gt; else () }&lt;/li&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>tree</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>seq</xqdoc:name><xqdoc:type occurrence="*">xs:integer</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>render</xqdoc:name><xqdoc:type>function(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>maxdepth</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(li)</xqdoc:type></xqdoc:return><xqdoc:body>function page:tree-list($tree as element(*),&#xD;
                                $seq as xs:integer*,&#xD;
                                $render as function(*),&#xD;
                                $maxdepth as xs:integer)&#xD;
as element(li){&#xD;
  let $pos:=page:section($seq)&#xD;
  &#xD;
  return &lt;li&gt;{&#xD;
         $render($pos,$tree),&#xD;
         if($tree  instance of element(directory) and $maxdepth &gt; 0)then&#xD;
          &lt;ol &gt;{ $tree/*!page:tree-list(.,($seq,position()),$render,$maxdepth -1 ) }&lt;/ol&gt;&#xD;
          else ()&#xD;
        }&lt;/li&gt;&#xD;
 &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="4"><xqdoc:name>page:tree-list2</xqdoc:name><xqdoc:signature>function page:tree-list2 ( $tree as element(*), $seq as xs:integer*, $render as function(*), $maxdepth as xs:integer ) as element(li) { let $pos:=page:section($seq) let $isNested:=$tree instance of element(directory) and $maxdepth &gt; 0 return &lt;li&gt;{ (if($isNested) then &lt;span class="caret"&gt; {$render($pos,$tree)}/ &lt;/span&gt; else $render($pos,$tree), if($isNested) then &lt;ul class="nested"&gt;{ $tree/*!page:tree-list2(.,($seq,position()),$render,$maxdepth -1 ) }&lt;/ul&gt; else () )}&lt;/li&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>tree</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>seq</xqdoc:name><xqdoc:type occurrence="*">xs:integer</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>render</xqdoc:name><xqdoc:type>function(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>maxdepth</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(li)</xqdoc:type></xqdoc:return><xqdoc:body>function page:tree-list2($tree as element(*),&#xD;
                                $seq as xs:integer*,&#xD;
                                $render as function(*),&#xD;
                                $maxdepth as xs:integer)&#xD;
as element(li){&#xD;
  let $pos:=page:section($seq)&#xD;
  let $isNested:=$tree instance of element(directory) and $maxdepth &gt; 0&#xD;
  return &lt;li&gt;{&#xD;
         (if($isNested)&#xD;
          &#xD;
          then &#xD;
            &lt;span class="caret"&gt;&#xD;
            {$render($pos,$tree)}/&#xD;
            &lt;/span&gt;&#xD;
            &#xD;
          else $render($pos,$tree),&#xD;
     &#xD;
         if($isNested) &#xD;
         then &#xD;
             &lt;ul class="nested"&gt;{ &#xD;
             $tree/*!page:tree-list2(.,($seq,position()),$render,$maxdepth -1 ) &#xD;
             }&lt;/ul&gt;&#xD;
              &#xD;
          else ()&#xD;
        )}&lt;/li&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
simple toc render&#xD;
</xqdoc:description><xqdoc:see>tree-list</xqdoc:see></xqdoc:comment><xqdoc:name>page:toc-render</xqdoc:name><xqdoc:signature>function page:toc-render ( $pos as xs:string,$el as element(*) ) as element(*) { let $c:=( &lt;span class="secno"&gt;{$pos}&lt;/span&gt;, &lt;span class="content"&gt;{$el/@name/string()}&lt;/span&gt; ) return if($el/@target) then &lt;a href="{$el/@target}"&gt;{ $c }&lt;/a&gt; else &lt;span&gt;{$c}&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pos</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>el</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(*)</xqdoc:type></xqdoc:return><xqdoc:body>function page:toc-render($pos as xs:string,$el as element(*))&#xD;
as element(*)&#xD;
{&#xD;
let $c:=(&#xD;
&lt;span class="secno"&gt;{$pos}&lt;/span&gt;,&#xD;
&lt;span class="content"&gt;{$el/@name/string()}&lt;/span&gt;&#xD;
)&#xD;
return if($el/@target) then&#xD;
 &lt;a href="{$el/@target}"&gt;{ $c }&lt;/a&gt;&#xD;
else&#xD;
 &lt;span&gt;{$c}&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
formated datetime&#xD;
</xqdoc:description><xqdoc:param>$when date to now</xqdoc:param></xqdoc:comment><xqdoc:name>page:date</xqdoc:name><xqdoc:signature>function page:date ( $when as xs:dateTime ) as element(span) { &lt;span title="{ $when }" &gt;{ format-dateTime($when, "[FNn], [D1o] [MNn] [Y0000]") }&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>when</xqdoc:name><xqdoc:type>xs:dateTime</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:date($when as xs:dateTime)&#xD;
as element(span)&#xD;
{&#xD;
  &lt;span title="{ $when }" &gt;{ format-dateTime($when, "[FNn], [D1o] [MNn] [Y0000]") }&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="0"><xqdoc:comment><xqdoc:description>&#xD;
formated datetime for now</xqdoc:description></xqdoc:comment><xqdoc:name>page:date</xqdoc:name><xqdoc:signature>function page:date ( ) as element(span) { page:date(current-dateTime()) }</xqdoc:signature><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:date()&#xD;
as element(span)&#xD;
{&#xD;
 page:date(current-dateTime())&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
active renderer names</xqdoc:description></xqdoc:comment><xqdoc:name>page:active-renderers</xqdoc:name><xqdoc:signature>function page:active-renderers ( $type as xs:string, $opts as map(*), $exclude as xs:string* ) as xs:string* { let $selected:=$opts?outputs?($type) let $renderers:=$opts(".renderers")?($type) return page:tokens($selected)[not(. = $exclude)] }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>type</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>exclude</xqdoc:name><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:active-renderers($type as xs:string,&#xD;
                        $opts as map(*),&#xD;
                        $exclude as xs:string*)&#xD;
as xs:string*{&#xD;
let $selected:=$opts?outputs?($type)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return page:tokens($selected)[not(. = $exclude)]&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
buttons of renderers&#xD;
</xqdoc:description><xqdoc:param>type global or module</xqdoc:param><xqdoc:param>exclude list of renderers to omit</xqdoc:param></xqdoc:comment><xqdoc:name>page:related-buttons</xqdoc:name><xqdoc:signature>function page:related-buttons ( $type as xs:string, $exclude as xs:string*, $opts as map(*) ) as element(span) { let $list:=page:active-renderers($type,$opts,$exclude) let $renderers:=$opts(".renderers")?($type) return &lt;span class="ml-2"&gt; { for $name in $list let $rend := $renderers[?name=$name] for $def in $rend order by $def?name return page:alink($def) }&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>type</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>exclude</xqdoc:name><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:related-buttons($type as xs:string,&#xD;
                        $exclude as xs:string*,&#xD;
                         $opts as map(*))                       &#xD;
as element(span)&#xD;
{&#xD;
let $list:=page:active-renderers($type,$opts,$exclude)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return &lt;span class="ml-2"&gt; {&#xD;
      for  $name in $list &#xD;
      let $rend :=  $renderers[?name=$name]&#xD;
      for $def in  $rend&#xD;
      order by $def?name&#xD;
      return page:alink($def)&#xD;
}&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
link to render output</xqdoc:description></xqdoc:comment><xqdoc:name>page:alink</xqdoc:name><xqdoc:signature>function page:alink ( $def as map(*) ) as element(a) { let $target:=if($def?output = ("xml","text")) then "_blank" else "_self" return &lt;a href="{ $def?uri }" title="{ page:line-wrap($def?description,60) }" class="badge badge-pill badge-light" style="margin-left:1em"&gt;{ attribute target { $target}, $def?name }&lt;/a&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>def</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(a)</xqdoc:type></xqdoc:return><xqdoc:body>function page:alink($def as map(*))&#xD;
as element(a){&#xD;
  let $target:=if($def?output = ("xml","text")) then "_blank" else "_self"&#xD;
  return &lt;a href="{ $def?uri }" title="{ page:line-wrap($def?description,60) }" &#xD;
        class="badge badge-pill badge-light"  style="margin-left:1em"&gt;{ &#xD;
                      attribute target { $target},&#xD;
                      $def?name }&lt;/a&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
table of renderers&#xD;
</xqdoc:description><xqdoc:param>type global or module</xqdoc:param><xqdoc:param>exclude list of renderers to omit</xqdoc:param></xqdoc:comment><xqdoc:name>page:related-docs</xqdoc:name><xqdoc:signature>function page:related-docs ( $type as xs:string, $opts as map(*), $exclude as xs:string* ) as element(table)? { let $list:=page:active-renderers($type,$opts,$exclude) let $renderers:=$opts(".renderers")?($type) return if(not(empty($list))) then &lt;table class="data"&gt; &lt;thead&gt; &lt;th&gt;View&lt;/th&gt; &lt;th&gt;Description&lt;/th&gt; &lt;th&gt;Format&lt;/th&gt; &lt;/thead&gt; &lt;tbody&gt; { for $name in $list let $rend := $renderers[?name=$name] return (for $def in $rend order by $def?name return &lt;tr&gt; &lt;td&gt;{page:alink($def)}&lt;/td&gt; &lt;td&gt;{ $def?description }&lt;/td&gt; &lt;td&gt;{ $def?output }&lt;/td&gt; &lt;/tr&gt;, if(empty($rend)) then &lt;tr&gt; &lt;td&gt;&lt;span class="badge badge-danger"&gt;{ $name }&lt;/span&gt;&lt;/td&gt; &lt;td&gt;No renderer found&lt;/td&gt; &lt;/tr&gt; else () ) } &lt;/tbody&gt; &lt;/table&gt; else () }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>type</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>exclude</xqdoc:name><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">element(table)</xqdoc:type></xqdoc:return><xqdoc:body>function page:related-docs($type as xs:string,&#xD;
                        $opts as map(*),&#xD;
                        $exclude as xs:string*)                       &#xD;
as element(table)?&#xD;
{&#xD;
 let $list:=page:active-renderers($type,$opts,$exclude)&#xD;
 let $renderers:=$opts(".renderers")?($type)&#xD;
 return if(not(empty($list))) then&#xD;
           &lt;table class="data"&gt;&#xD;
                 &lt;thead&gt;&#xD;
                 &lt;th&gt;View&lt;/th&gt;&#xD;
                 &lt;th&gt;Description&lt;/th&gt;&#xD;
                 &lt;th&gt;Format&lt;/th&gt;&#xD;
                 &lt;/thead&gt;&#xD;
                 &lt;tbody&gt;&#xD;
                 {&#xD;
                  for  $name in $list &#xD;
                  let $rend :=  $renderers[?name=$name]&#xD;
&#xD;
                  return (for $def in  $rend&#xD;
                         order by $def?name&#xD;
                         return &lt;tr&gt;&#xD;
                                 &lt;td&gt;{page:alink($def)}&lt;/td&gt;&#xD;
                                  &lt;td&gt;{ $def?description }&lt;/td&gt;&#xD;
                                  &lt;td&gt;{ $def?output }&lt;/td&gt;&#xD;
                                 &lt;/tr&gt;,&#xD;
                         if(empty($rend)) &#xD;
                         then &lt;tr&gt;&#xD;
                                &lt;td&gt;&lt;span class="badge badge-danger"&gt;{ $name }&lt;/span&gt;&lt;/td&gt;&#xD;
                                &lt;td&gt;No renderer found&lt;/td&gt;&#xD;
                               &lt;/tr&gt;&#xD;
                         else ()  &#xD;
                             )&#xD;
                  }    &#xD;
                 &lt;/tbody&gt;&#xD;
        &lt;/table&gt;&#xD;
       else&#xD;
         ()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
related docs details&#xD;
</xqdoc:description><xqdoc:param>$type "global" or "module"</xqdoc:param></xqdoc:comment><xqdoc:name>page:related-links</xqdoc:name><xqdoc:signature>function page:related-links ( $type as xs:string, $exclude as xs:string, $opts as map(*) ) as element(details)? { let $t:=page:related-docs($type, $opts,$exclude) return if ($t) then &lt;details&gt; &lt;summary&gt;Related documents&lt;/summary&gt; {$t} &lt;/details&gt; else () }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>type</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>exclude</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">element(details)</xqdoc:type></xqdoc:return><xqdoc:body>function page:related-links($type as xs:string, $exclude as xs:string, $opts as map(*))&#xD;
as element(details)?&#xD;
{&#xD;
let $t:=page:related-docs($type, $opts,$exclude)&#xD;
return if ($t) then&#xD;
         &lt;details&gt;&#xD;
            &lt;summary&gt;Related documents&lt;/summary&gt;&#xD;
            {$t}&#xD;
          &lt;/details&gt;&#xD;
        else&#xD;
           ()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description><span/></xqdoc:description></xqdoc:comment><xqdoc:name>page:badge</xqdoc:name><xqdoc:signature>function page:badge ( $label as xs:string,$color as xs:string,$title as xs:string ) as element(span) { &lt;span class="badge badge-{$color}" title="{ $title }"&gt;{$label}&lt;/span&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>label</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>color</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>title</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(span)</xqdoc:type></xqdoc:return><xqdoc:body>function page:badge($label as xs:string,$color as xs:string,$title as xs:string)&#xD;
as element(span)&#xD;
{&#xD;
  &lt;span class="badge badge-{$color}" title="{ $title }"&gt;{$label}&lt;/span&gt;&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
true() if $url represents a url&#xD;
</xqdoc:description><xqdoc:see>http://urlregex.com/</xqdoc:see></xqdoc:comment><xqdoc:name>page:is-url</xqdoc:name><xqdoc:signature>function page:is-url ( $url as xs:string ) as xs:boolean { matches($url,"^(https?|ftp|file)://[-a-zA-Z0-9+&amp;amp;@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&amp;amp;@#/%=~_|]","j") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>url</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:return><xqdoc:body>function page:is-url($url as xs:string)&#xD;
as xs:boolean&#xD;
{&#xD;
  matches($url,"^(https?|ftp|file)://[-a-zA-Z0-9+&amp;amp;@#/%?=~_|!:,.;]*[-a-zA-Z0-9+&amp;amp;@#/%=~_|]","j")&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
parse tokens from comma space delimited string&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>page:tokens</xqdoc:name><xqdoc:signature>function page:tokens ( $s as xs:string ) as xs:string* { $s=&gt;normalize-space()=&gt;tokenize("[\s,]+") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>s</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:tokens($s as xs:string)&#xD;
 as xs:string*&#xD;
 {&#xD;
 $s=&gt;normalize-space()=&gt;tokenize("[\s,]+") &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
extract comment for name</xqdoc:description></xqdoc:comment><xqdoc:name>page:comment-for</xqdoc:name><xqdoc:signature>function page:comment-for ( $name as xs:string,$v as element(xqdoc:parameters) ) as xs:string* { for $comment in $v/../xqdoc:comment/xqdoc:param[ starts-with(normalize-space(.), $name) or starts-with(normalize-space(.), concat('$',$name)) ] return substring-after(normalize-space($comment), $name) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>v</xqdoc:name><xqdoc:type>element(xqdoc:parameters)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:comment-for($name as xs:string,$v as element(xqdoc:parameters))&#xD;
as xs:string*&#xD;
{&#xD;
 for $comment in $v/../xqdoc:comment/xqdoc:param[&#xD;
                                       starts-with(normalize-space(.), $name) or &#xD;
                                       starts-with(normalize-space(.), concat('$',$name))&#xD;
                                     ]&#xD;
 return substring-after(normalize-space($comment), $name)  &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
line count</xqdoc:description></xqdoc:comment><xqdoc:name>page:line-count</xqdoc:name><xqdoc:signature>function page:line-count ( $txt as xs:string? ) as xs:integer { tokenize($txt, '(\r\n?|\n\r?)')=&gt;count() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>txt</xqdoc:name><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:integer</xqdoc:type></xqdoc:return><xqdoc:body>function page:line-count($txt as xs:string?)&#xD;
as xs:integer{&#xD;
  tokenize($txt, '(\r\n?|\n\r?)')=&gt;count()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
break lines longer than width by inserting newline chars&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>page:line-wrap</xqdoc:name><xqdoc:signature>function page:line-wrap ( $string as xs:string?,$width as xs:integer ) as xs:string? { $string=&gt;normalize-space()=&gt;concat(" ")=&gt;replace(``[(.{0,`{ $width }`}) ]``,'$1&amp;#xA;') }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>string</xqdoc:name><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>width</xqdoc:name><xqdoc:type>xs:integer</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function page:line-wrap($string as xs:string?,$width as xs:integer)&#xD;
as xs:string?{&#xD;
  $string=&gt;normalize-space()=&gt;concat(" ")=&gt;replace(``[(.{0,`{ $width }`})&#xD;
]``,'$1&amp;#xA;')&#xD;
}</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>