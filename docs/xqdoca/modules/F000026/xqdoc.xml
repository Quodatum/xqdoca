<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-05-17T18:35:19.705+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum:xqdoca.namespaces</xqdoc:uri><xqdoc:name>xqn</xqdoc:name><xqdoc:comment><xqdoc:description><p>namespace and qname utils</p></xqdoc:description><xqdoc:author>Andy Bunce, Quodatum, License: Apache-2.0</xqdoc:author><xqdoc:custom tag="copyright">(c) 2019-2026 Quodatum Ltd</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version "3.1";&#xD;
(:~&#xD;
 &lt;p&gt;namespace and qname utils&lt;/p&gt;&#xD;
 @copyright (c) 2019-2026 Quodatum Ltd&#xD;
 @author Andy Bunce, Quodatum, License: Apache-2.0&#xD;
:)&#xD;
module namespace xqn = 'quodatum:xqdoca.namespaces';&#xD;
&#xD;
(:~  parse qname into parts&#xD;
@param $e is from QName or TOKEN in some cases e.g "count"&#xD;
@param $prefixes map of namespaces&#xD;
@param $defaultns namespace for no prefix&#xD;
@error xqn:qmap NO TOK&#xD;
@return &lt;pre&gt;&#xD;
 map{&#xD;
    "uri": ..,&#xD;
    "name": ..} &#xD;
 }&#xD;
 :&lt;/pre&gt;&#xD;
 :)&#xD;
declare &#xD;
function xqn:qmap($token as xs:string?, $prefixes as map(*), $defaultns as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $_:=if(empty($token)) then error(xs:QName("xqn:qmap"),"NO TOK")&#xD;
 return if(starts-with($token,"Q{"))&#xD;
        then map{&#xD;
           "uri": $token=&gt;substring-after("{")=&gt;substring-before("}"),&#xD;
           "name": $token=&gt;substring-after("}") &#xD;
        }&#xD;
        else&#xD;
          let $n:=tokenize($token,":")&#xD;
          let $prefix:=if(count($n)=2)then $n[1] else ()&#xD;
          let $name:=if(count($n)=2)then  $n[2] else $n[1]&#xD;
          let $uri:=if(empty($prefix)) &#xD;
                    then  $defaultns&#xD;
                    else if( map:contains($prefixes,$prefix)) &#xD;
                        then $prefixes?($prefix)&#xD;
                        else &#xD;
                          let $_:= trace(map:size($prefixes),"missing prefix:" || $prefix || ": ")&#xD;
                          return error(xs:QName("xqn:qmap"),"Failed process token: " || $token)&#xD;
                      &#xD;
          return map{&#xD;
                    "uri": $uri,&#xD;
                    "name": $name} &#xD;
};&#xD;
&#xD;
(:~ true if $uri and $name match $qmap :)&#xD;
declare function xqn:eq($qmap as map(*),$uri as xs:string, $name as xs:string) &#xD;
as xs:boolean&#xD;
{&#xD;
  $qmap?name=$name and $qmap?uri=$uri&#xD;
};&#xD;
&#xD;
&#xD;
(:~ &#xD;
 : return clark-notation '{uri}name'&#xD;
  :)&#xD;
declare function xqn:clark-name($uri as xs:string, &#xD;
                                $name as xs:string)&#xD;
as xs:string&#xD;
{&#xD;
  ``[{`{ $uri }`}`{ $name }`]``&#xD;
};&#xD;
&#xD;
(:~ &#xD;
 : @return prefix:name if available or clark-notation&#xD;
  :)&#xD;
declare function xqn:prefixed-name($uri as xs:string, &#xD;
                                $name as xs:string,&#xD;
                                $prefixes as map(*))&#xD;
as xs:string&#xD;
{&#xD;
  let $prefix:= map:for-each($prefixes,function($k,$v){ if($v=$uri)then $k else () })=&gt;head() &#xD;
  return if($prefix) then&#xD;
           concat(head($prefix),":",$name)&#xD;
         else&#xD;
           xqn:clark-name( $uri, $name )&#xD;
};&#xD;
&#xD;
(:~ namespace for prefix&#xD;
 : @param $prefix prefix to lookup&#xD;
 : @param $default namespace to use if prefix empty&#xD;
 : @param $map keys are prefixes items are namespaces&#xD;
 : @return namespace for prefix&#xD;
  :)&#xD;
declare function xqn:map-prefix($prefix as xs:string?, $default as xs:string, $prefixes as map(*))&#xD;
as xs:string{&#xD;
  if(empty($prefix)) then&#xD;
    $default&#xD;
  else if(map:contains($prefixes, $prefix))then &#xD;
   $prefixes?($prefix)&#xD;
   else&#xD;
   let $_:=trace($prefixes,"map-prefix: ")&#xD;
   return "*** " || trace($prefix,"**prefix not found:" ),&#xD;
   error()&#xD;
};&#xD;
&#xD;
(:~  parse URIQualifiedName into parts&#xD;
 : @param $e is URIQualifiedName&#xD;
 : @todo use regx&#xD;
 :)&#xD;
declare function xqn:uriqname($e as element(URIQualifiedName))&#xD;
as map(*)&#xD;
{&#xD;
let $n:=tokenize($e,"}")&#xD;
return map{"uri": substring($n[1],3),&#xD;
           "name": $n[2]} &#xD;
};&#xD;
&#xD;
(:~  map of static namespaces :)&#xD;
declare function xqn:static-prefix-map($platform as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 fetch:text(resolve-uri(``[../etc/models/`{ $platform }`.json]``,static-base-uri()))&#xD;
 =&gt;parse-json()&#xD;
 (: =&gt;trace("PLATFORM ")  :)&#xD;
};&#xD;
&#xD;
</xqdoc:body></xqdoc:module><xqdoc:namespaces><xqdoc:namespace prefix="xqn" uri="quodatum:xqdoca.namespaces"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/><xqdoc:namespace prefix="fetch" uri="http://basex.org/modules/fetch"/></xqdoc:namespaces><xqdoc:variables/><xqdoc:functions><xqdoc:function arity="3"><xqdoc:name>xqn:qmap</xqdoc:name><xqdoc:signature>function xqn:qmap ( $token as xs:string?, $prefixes as map(*), $defaultns as xs:string ) as map(*) { let $_:=if(empty($token)) then error(xs:QName("xqn:qmap"),"NO TOK") return if(starts-with($token,"Q{")) then map{ "uri": $token=&gt;substring-after("{")=&gt;substring-before("}"), "name": $token=&gt;substring-after("}") } else let $n:=tokenize($token,":") let $prefix:=if(count($n)=2)then $n[1] else () let $name:=if(count($n)=2)then $n[2] else $n[1] let $uri:=if(empty($prefix)) then $defaultns else if( map:contains($prefixes,$prefix)) then $prefixes?($prefix) else let $_:= trace(map:size($prefixes),"missing prefix:" || $prefix || ": ") return error(xs:QName("xqn:qmap"),"Failed process token: " || $token) return map{ "uri": $uri, "name": $name} }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>token</xqdoc:name><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>defaultns</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:qmap($token as xs:string?, $prefixes as map(*), $defaultns as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $_:=if(empty($token)) then error(xs:QName("xqn:qmap"),"NO TOK")&#xD;
 return if(starts-with($token,"Q{"))&#xD;
        then map{&#xD;
           "uri": $token=&gt;substring-after("{")=&gt;substring-before("}"),&#xD;
           "name": $token=&gt;substring-after("}") &#xD;
        }&#xD;
        else&#xD;
          let $n:=tokenize($token,":")&#xD;
          let $prefix:=if(count($n)=2)then $n[1] else ()&#xD;
          let $name:=if(count($n)=2)then  $n[2] else $n[1]&#xD;
          let $uri:=if(empty($prefix)) &#xD;
                    then  $defaultns&#xD;
                    else if( map:contains($prefixes,$prefix)) &#xD;
                        then $prefixes?($prefix)&#xD;
                        else &#xD;
                          let $_:= trace(map:size($prefixes),"missing prefix:" || $prefix || ": ")&#xD;
                          return error(xs:QName("xqn:qmap"),"Failed process token: " || $token)&#xD;
                      &#xD;
          return map{&#xD;
                    "uri": $uri,&#xD;
                    "name": $name} &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
true if $uri and $name match $qmap</xqdoc:description></xqdoc:comment><xqdoc:name>xqn:eq</xqdoc:name><xqdoc:signature>function xqn:eq ( $qmap as map(*),$uri as xs:string, $name as xs:string ) as xs:boolean { $qmap?name=$name and $qmap?uri=$uri }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>qmap</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:eq($qmap as map(*),$uri as xs:string, $name as xs:string) &#xD;
as xs:boolean&#xD;
{&#xD;
  $qmap?name=$name and $qmap?uri=$uri&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
return clark-notation '{uri}name'&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqn:clark-name</xqdoc:name><xqdoc:signature>function xqn:clark-name ( $uri as xs:string, $name as xs:string ) as xs:string { ``[{`{ $uri }`}`{ $name }`]`` }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:clark-name($uri as xs:string, &#xD;
                                $name as xs:string)&#xD;
as xs:string&#xD;
{&#xD;
  ``[{`{ $uri }`}`{ $name }`]``&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
</xqdoc:description><xqdoc:return>prefix:name if available or clark-notation</xqdoc:return></xqdoc:comment><xqdoc:name>xqn:prefixed-name</xqdoc:name><xqdoc:signature>function xqn:prefixed-name ( $uri as xs:string, $name as xs:string, $prefixes as map(*) ) as xs:string { let $prefix:= map:for-each($prefixes,function($k,$v){ if($v=$uri)then $k else () })=&gt;head() return if($prefix) then concat(head($prefix),":",$name) else xqn:clark-name( $uri, $name ) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>uri</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:prefixed-name($uri as xs:string, &#xD;
                                $name as xs:string,&#xD;
                                $prefixes as map(*))&#xD;
as xs:string&#xD;
{&#xD;
  let $prefix:= map:for-each($prefixes,function($k,$v){ if($v=$uri)then $k else () })=&gt;head() &#xD;
  return if($prefix) then&#xD;
           concat(head($prefix),":",$name)&#xD;
         else&#xD;
           xqn:clark-name( $uri, $name )&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
namespace for prefix&#xD;
</xqdoc:description><xqdoc:param>$prefix prefix to lookup</xqdoc:param><xqdoc:param>$default namespace to use if prefix empty</xqdoc:param><xqdoc:param>$map keys are prefixes items are namespaces</xqdoc:param><xqdoc:return>namespace for prefix</xqdoc:return></xqdoc:comment><xqdoc:name>xqn:map-prefix</xqdoc:name><xqdoc:signature>function xqn:map-prefix ( $prefix as xs:string?, $default as xs:string, $prefixes as map(*) ) as xs:string { if(empty($prefix)) then $default else if(map:contains($prefixes, $prefix))then $prefixes?($prefix) else let $_:=trace($prefixes,"map-prefix: ") return "*** " || trace($prefix,"**prefix not found:" ), error() }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>prefix</xqdoc:name><xqdoc:type occurrence="?">xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>default</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:map-prefix($prefix as xs:string?, $default as xs:string, $prefixes as map(*))&#xD;
as xs:string{&#xD;
  if(empty($prefix)) then&#xD;
    $default&#xD;
  else if(map:contains($prefixes, $prefix))then &#xD;
   $prefixes?($prefix)&#xD;
   else&#xD;
   let $_:=trace($prefixes,"map-prefix: ")&#xD;
   return "*** " || trace($prefix,"**prefix not found:" ),&#xD;
   error()&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
parse URIQualifiedName into parts&#xD;
</xqdoc:description><xqdoc:param>$e is URIQualifiedName</xqdoc:param><xqdoc:custom tag="todo">use regx</xqdoc:custom></xqdoc:comment><xqdoc:name>xqn:uriqname</xqdoc:name><xqdoc:signature>function xqn:uriqname ( $e as element(URIQualifiedName) ) as map(*) { let $n:=tokenize($e,"}") return map{"uri": substring($n[1],3), "name": $n[2]} }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(URIQualifiedName)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:uriqname($e as element(URIQualifiedName))&#xD;
as map(*)&#xD;
{&#xD;
let $n:=tokenize($e,"}")&#xD;
return map{"uri": substring($n[1],3),&#xD;
           "name": $n[2]} &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
map of static namespaces</xqdoc:description></xqdoc:comment><xqdoc:name>xqn:static-prefix-map</xqdoc:name><xqdoc:signature>function xqn:static-prefix-map ( $platform as xs:string ) as map(*) { fetch:text(resolve-uri(``[../etc/models/`{ $platform }`.json]``,static-base-uri())) =&gt;parse-json() (: =&gt;trace("PLATFORM ") :) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>platform</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqn:static-prefix-map($platform as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 fetch:text(resolve-uri(``[../etc/models/`{ $platform }`.json]``,static-base-uri()))&#xD;
 =&gt;parse-json()&#xD;
 (: =&gt;trace("PLATFORM ")  :)&#xD;
}</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>