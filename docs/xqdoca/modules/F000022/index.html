<!DOCTYPE html><html xmlns="http:/www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><meta http-equiv="Generator" content="xqdoca - https://github.com/quodatum/xqdoca"/><title>XQDocA - xqDocA - xqDocA</title><link rel="shortcut icon" type="image/x-icon" href="../../resources/xqdoc.png"/><link rel="stylesheet" type="text/css" href="../../resources/prism/1.29.0/prism.css"/><link rel="stylesheet" type="text/css" href="../../resources/page.css"/><link rel="stylesheet" type="text/css" href="../../resources/query.css"/><link rel="stylesheet" type="text/css" href="../../resources/base.css"/></head><body class="home" id="top"><div id="main" class="line-numbers"><div><h1><span class="badge badge-info">quodatum:xqdoca.parser</span> 
                    <small>library module</small><div style="float:right"></div></h1><nav id="toc"><h2><a href="../../index.html">XQDocA</a>
                / Module
       </h2><h3><a id="contents"></a><span class="">quodatum:xqdoca.parser</span></h3><ol class="toc"><li><a href="#summary"><span class="secno">1 </span><span class="content">Summary</span></a></li><li><a href="#imports"><span class="secno">2 </span><span class="content">Imports</span></a></li><li><a href="#variables"><span class="secno">3 </span><span class="content">Variables</span></a><ol class="toc"><li><a href="#$xqp:trace"><span class="secno">3.1</span><span class="content">$xqp:trace</span><div style="float:right"></div></a></li><li><a href="#$xqp:xparse_opts"><span class="secno">3.2</span><span class="content">$xqp:xparse_opts</span><div style="float:right"></div></a></li></ol></li><li><a href="#functions"><span class="secno">4 </span><span class="content">Functions</span></a><ol class="toc"><li><a href="#xqp:default-fn-uri"><span class="secno">4.1</span><span class="content" title="&#xD;&#xA;default function namespace&#xD;&#xA;NOTE if parse failed will return &quot;http://www.w3.org/2005/xpath-functions&quot;&#xD;&#xA;">default-fn-uri<div style="float:right"></div></span></a></li><li><a href="#xqp:funmap"><span class="secno">4.2</span><span class="content" title="&#xD;&#xA;map of function declarations&#xD;&#xA;">funmap<div style="float:right"></div></span></a></li><li><a href="#xqp:invoke-arrow"><span class="secno">4.3</span><span class="content" title="&#xD;&#xA;build invoked nodes for arrow expression&#xD;&#xA;">invoke-arrow<div style="float:right"></div></span></a></li><li><a href="#xqp:invoke-fn"><span class="secno">4.4</span><span class="content" title="&#xD;&#xA;build invoked nodes for function call&#xD;&#xA;">invoke-fn<div style="float:right"></div></span></a></li><li><a href="#xqp:parse"><span class="secno">4.5</span><span class="content" title="&#xD;&#xA;parse XQuery&#xD;&#xA;result is &lt;XQuery&gt; or &lt;ERROR&gt;&#xD;&#xA;">parse<div style="float:right"></div></span></a></li><li><a href="#xqp:ref-variable"><span class="secno">4.6</span><span class="content" title="&#xD;&#xA;build invoked nodes for function call&#xD;&#xA;">ref-variable<div style="float:right"></div></span></a></li><li><a href="#xqp:references"><span class="secno">4.7</span><span class="content" title="&#xD;&#xA;scan tree below $e for references&#xD;&#xA;">references<div style="float:right"></div></span></a></li><li><a href="#xqp:trace"><span class="secno">4.8</span><span class="content" title="">trace<div style="float:right"></div></span></a></li></ol></li><li><a href="#namespaces"><span class="secno">5 </span><span class="content">Namespaces</span></a></li><li><a href="#restxq"><span class="secno">6 </span><span class="content">RestXQ</span></a></li><li><a href="#source"><span class="secno">7 </span><span class="content">Source</span></a></li></ol></nav><section id="summary"><h2>Summary</h2><div><p>generate and Analyse XQuery parse tree</p></div><dl><dt title="1">Authors</dt><dd><ul><li><span>Andy Bunce, Quodatum, License: Apache-2.0</span></li></ul></dd></dl><dl><dt title="1">Custom</dt><dd><ul><li><span><span class="badge badge-pill badge-light">@copyright</span>:
                <span>(c) 2019-2026 Quodatum Ltd</span></span></li></ul></dd></dl><details><summary>Related documents</summary><table class="data"><thead><th>View</th><th>Description</th><th>Format</th></thead><tbody><tr><td><a href="xqdoc.xml" title="xqDoc xml file from the source module " class="badge badge-pill badge-light" style="margin-left:1em" target="_blank">xqdoc</a></td><td>xqDoc xml file from the source module</td><td>xml</td></tr><tr><td><a href="xqparse.xml" title="xqparse xml file from the source module " class="badge badge-pill badge-light" style="margin-left:1em" target="_blank">xqparse</a></td><td>xqparse xml file from the source module</td><td>xml</td></tr></tbody></table></details></section><section id="imports"><h2>Imports</h2><p>
    This module is imported by
    <span class="badge badge-info">1</span> modules. It imports
    <span class="badge badge-info">2</span> modules.
    </p><div style="display: flex; justify-content: space-between; align-items: center;"><div style="flex-grow: 1;padding:10px;"><div style="text-align: right;"><span><a href="../../modules/F000020/index.html" title="lib/model.xqm">quodatum:xqdoca.model</a></span></div></div><div style="display: flex; flex-direction: column; justify-content: center; padding:10px; background-color:blanchedalmond;"><div><div>imports</div>→</div><div class="badge badge-info">quodatum:xqdoca.parser</div><div><div>imports</div>→</div></div><div style="flex-grow: 1;padding:10px;justify-content: space-between;align-items:center;"><div style=""><div style="text-align: left;"><span class="badge badge-warning" title="Externally defined">expkg-zone58:text.parse</span></div><div style="text-align: left;"><span><a href="../../modules/F000026/index.html" title="lib/xqdoc-namespace.xqm">quodatum:xqdoca.namespaces</a></span></div></div></div></div></section><section id="variables"><h2>Variables</h2><div class="div3"><h3><a id="$xqp:trace"></a><a id="{quodatum:xqdoca.parser}$trace"></a><a href="#$xqp:trace">3.1 </a>$xqp:trace</h3><dl><dt class="label">Summary</dt><dd></dd><dt class="label">Type</dt><dd>xs:boolean</dd></dl><details open="open"><summary>Source ( 1 lines)</summary><pre><code class="language-xquery" data-prismjs-copy="Copy to clipboard">variable $xqp:trace as xs:boolean:=false()</code></pre></details></div><div class="div3"><h3><a id="$xqp:xparse_opts"></a><a id="{quodatum:xqdoca.parser}$xparse_opts"></a><a href="#$xqp:xparse_opts">3.2 </a>$xqp:xparse_opts</h3><dl><dt class="label">Summary</dt><dd>&#xD;
xparser defaults</dd><dt class="label">Type</dt><dd></dd></dl><details open="open"><summary>Source ( 5 lines)</summary><pre><code class="language-xquery" data-prismjs-copy="Copy to clipboard">variable $xqp:xparse_opts:=map{&#xD;
  "basex":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
  , "fat":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
&#xD;
}</code></pre></details></div></section><section id="functions"><h2>Functions</h2><div class="div3"><h3><a id="xqp:default-fn-uri"></a><a id="{quodatum:xqdoca.parser}default-fn-uri#1"></a><a href="#xqp:default-fn-uri">4.1 </a>xqp:default-fn-uri</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}default-fn-uri#1">#1</a></span></p><dt class="label">Summary</dt><dd>&#xD;
default function namespace&#xD;
NOTE if parse failed will return "http://www.w3.org/2005/xpath-functions"&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:default-fn-uri</code>
		  ( 
			<code class="arg">$xqparse</code><code class="as"> as </code><code class="type">element(XQuery)</code> )<code class="as"> as </code><code class="type">xs:string</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>xqparse<code class="as"> as </code><code class="return-type">element(XQuery)</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">xs:string</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 8 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:default-fn-uri($xqparse as element(XQuery))&#xD;
as xs:string&#xD;
{&#xD;
  let $def-fn:= $xqparse/*//Prolog/DefaultNamespaceDecl&#xD;
  return if( empty($def-fn) ) &#xD;
         then "http://www.w3.org/2005/xpath-functions"&#xD;
         else $def-fn/URILiteral!substring(.,2,string-length(.)-2)&#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:funmap"></a><a id="{quodatum:xqdoca.parser}funmap#3"></a><a href="#xqp:funmap">4.2 </a>xqp:funmap</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}funmap#3">#3</a></span></p><dt class="label">Summary</dt><dd>&#xD;
map of function declarations&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:funmap</code>
		  ( 
			<code class="arg">$e</code><code class="as"> as </code><code class="type">element(XQuery)</code>, <code class="arg">$prefixes</code><code class="as"> as </code><code class="type">map(*)</code>, <code class="arg">$def-fn</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">map(*)</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>e<code class="as"> as </code><code class="return-type">element(XQuery)</code></li><li>prefixes<code class="as"> as </code><code class="return-type">map(*)</code></li><li>def-fn<code class="as"> as </code><code class="return-type">xs:string</code> default function namespace</li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">map(*)</code></li></ul></dd><dl><dt title="1">Tags</dt><dd><ul><li><span><span class="badge badge-pill badge-light">@result</span>:
                <span>map where keys are Qname with # arity items are xqParse trees</span></span></li></ul></dd></dl><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 17 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:funmap($e as element(XQuery),$prefixes as map(*),$def-fn as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $items:=for $f in $e//FunctionDecl&#xD;
             let $name:=$f/*[2]&#xD;
             let $name:=if($name instance of element(QName)&#xD;
                        or $name instance of element(TOKEN)) then&#xD;
                              xqn:qmap($name,$prefixes,$def-fn)&#xD;
                        else if($name instance of element(URIQualifiedName)) then&#xD;
                                xqn:uriqname($name)&#xD;
                        else &#xD;
                             error(xs:QName("xqp:funmap"), "bad name: ", $name)&#xD;
             let $arity:=count($f/(Param|ParamList/Param))&#xD;
             let $key:=concat("Q{",$name?uri,"}",$name?name,"#",$arity)&#xD;
             return map:entry($key,$f)&#xD;
 return map:merge($items)&#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:invoke-arrow"></a><a id="{quodatum:xqdoca.parser}invoke-arrow#3"></a><a href="#xqp:invoke-arrow">4.3 </a>xqp:invoke-arrow</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}invoke-arrow#3">#3</a></span></p><dt class="label">Summary</dt><dd>&#xD;
build invoked nodes for arrow expression&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:invoke-arrow</code>
		  ( 
			<code class="arg">$e</code><code class="as"> as </code><code class="type">element(ArrowExpr)</code>, <code class="arg">$prefixes</code><code class="as"> as </code><code class="type">function(*)</code>, <code class="arg">$def-fn</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">element(xqdoc:invoked)*</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>e<code class="as"> as </code><code class="return-type">element(ArrowExpr)</code> is FunctionCall or ArrowExpr</li><li>prefixes<code class="as"> as </code><code class="return-type">function(*)</code></li><li>def-fn<code class="as"> as </code><code class="return-type">xs:string</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">element(xqdoc:invoked) *</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 15 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:invoke-arrow($e as element(ArrowExpr),&#xD;
                                  $prefixes as function(*),&#xD;
                                  $def-fn as xs:string)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
for $arrow in $e/TOKEN[. = "=&amp;gt;"]&#xD;
let $fname:=$arrow/(following-sibling::QName|following-sibling::TOKEN)&#xD;
let $arglist:=$arrow/following-sibling::ArgumentList&#xD;
let $arity:=1+count($arglist/*[not(self::TOKEN)])&#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt; &#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:invoke-fn"></a><a id="{quodatum:xqdoca.parser}invoke-fn#3"></a><a href="#xqp:invoke-fn">4.4 </a>xqp:invoke-fn</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}invoke-fn#3">#3</a></span></p><dt class="label">Summary</dt><dd>&#xD;
build invoked nodes for function call&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:invoke-fn</code>
		  ( 
			<code class="arg">$e</code><code class="as"> as </code><code class="type">element( (:  FunctionCall :) )</code>, <code class="arg">$prefixes</code><code class="as"> as </code><code class="type">map(*)</code>, <code class="arg">$def-fn</code> )<code class="as"> as </code><code class="type">element(xqdoc:invoked)*</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>e<code class="as"> as </code><code class="return-type">element( (:  FunctionCall :) )</code> is FunctionCall or ArrowExpr</li><li>prefixes<code class="as"> as </code><code class="return-type">map(*)</code></li><li>def-fn<code class="as"> as </code><code class="return-type"></code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">element(xqdoc:invoked) *</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 19 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:invoke-fn(&#xD;
                 $e as element( (:  FunctionCall :) ),&#xD;
                 $prefixes as map(*),&#xD;
                 $def-fn)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
&#xD;
let $commas:=count($e/ArgumentList/TOKEN[.=","])&#xD;
let $hasarg:=boolean($e/ArgumentList/*[not(self::TOKEN)])&#xD;
let $arity:= if($hasarg) then 1+$commas else 0&#xD;
let $arity:= if(name($e)="ArrowExpr") then $arity +1 else $arity&#xD;
let $fname:= $e/(QName|URIQualifiedName|TOKEN)/string()            &#xD;
let $_:= if(empty($fname)) then trace($e,"??????") &#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt;   &#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:parse"></a><a id="{quodatum:xqdoca.parser}parse#2"></a><a href="#xqp:parse">4.5 </a>xqp:parse</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}parse#2">#2</a></span></p><dt class="label">Summary</dt><dd>&#xD;
parse XQuery&#xD;
result is &lt;XQuery&gt; or &lt;ERROR&gt;&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:parse</code>
		  ( 
			<code class="arg">$xq</code><code class="as"> as </code><code class="type">xs:string</code>, <code class="arg">$platform</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">element(*)</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>xq<code class="as"> as </code><code class="return-type">xs:string</code></li><li>platform<code class="as"> as </code><code class="return-type">xs:string</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">element(*)</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 5 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:parse($xq as xs:string,$platform as xs:string)&#xD;
as element(*)&#xD;
{ &#xD;
  xp:parse($xq ,$xqp:xparse_opts($platform)) &#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:ref-variable"></a><a id="{quodatum:xqdoca.parser}ref-variable#3"></a><a href="#xqp:ref-variable">4.6 </a>xqp:ref-variable</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}ref-variable#3">#3</a></span></p><dt class="label">Summary</dt><dd>&#xD;
build invoked nodes for function call&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:ref-variable</code>
		  ( 
			<code class="arg">$e</code><code class="as"> as </code><code class="type">element(*)</code>, <code class="arg">$prefixes</code><code class="as"> as </code><code class="type">map(*)</code>, <code class="arg">$def-fn</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">element(xqdoc:ref-variable)</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>e<code class="as"> as </code><code class="return-type">element(*)</code> is variable reference @@TODO</li><li>prefixes<code class="as"> as </code><code class="return-type">map(*)</code></li><li>def-fn<code class="as"> as </code><code class="return-type">xs:string</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">element(xqdoc:ref-variable)</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 11 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:ref-variable($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(xqdoc:ref-variable)&#xD;
{&#xD;
&#xD;
let $fname:= if($e/QName) then $e/QName/string() else $e/TOKEN[1]/string() &#xD;
let $qname:=xqn:qmap($fname, $prefixes, $def-fn)&#xD;
 return &lt;xqdoc:ref-variable &gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:ref-variable&gt;   &#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:references"></a><a id="{quodatum:xqdoca.parser}references#3"></a><a href="#xqp:references">4.7 </a>xqp:references</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}references#3">#3</a></span></p><dt class="label">Summary</dt><dd>&#xD;
scan tree below $e for references&#xD;
</dd><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:references</code>
		  ( 
			<code class="arg">$e</code><code class="as"> as </code><code class="type">element(*)</code>, <code class="arg">$prefixes</code><code class="as"> as </code><code class="type">map(*)</code>, <code class="arg">$def-fn</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">element(*)*</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>e<code class="as"> as </code><code class="return-type">element(*)</code>xpand function to map prefixes to namespaces</li><li>prefixes<code class="as"> as </code><code class="return-type">map(*)</code></li><li>def-fn<code class="as"> as </code><code class="return-type">xs:string</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">element(*) *</code> sequence of xqdoc:invoked and xqdoc:var-refences elements</li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 7 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:references($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(*)*&#xD;
{&#xD;
  $e//FunctionCall!xqp:invoke-fn(.,$prefixes, $def-fn),&#xD;
  $e//ArrowExpr!xqp:invoke-arrow(.,$prefixes, $def-fn),&#xD;
  $e//VarRef!xqp:ref-variable(.,$prefixes, $def-fn) &#xD;
}</code></pre></details></div><div class="div3"><h3><a id="xqp:trace"></a><a id="{quodatum:xqdoca.parser}trace#2"></a><a href="#xqp:trace">4.8 </a>xqp:trace</h3><p>Arities: <span style="margin-left:1em"><a href="#{quodatum:xqdoca.parser}trace#2">#2</a></span></p><dt class="label">Signatures</dt><dd><div class="proto"><code class="function">xqp:trace</code>
		  ( 
			<code class="arg">$items</code><code class="as"> as </code><code class="type">item()*</code>, <code class="arg">$label</code><code class="as"> as </code><code class="type">xs:string</code> )<code class="as"> as </code><code class="type">item()*</code></div></dd><dt class="label">Parameters</dt><dd><ul><li>items<code class="as"> as </code><code class="return-type">item()*</code></li><li>label<code class="as"> as </code><code class="return-type">xs:string</code></li></ul></dd><dt class="label">Return</dt><dd><ul><li><code class="return-type">item() *</code></li></ul></dd><details><summary>Invoked by 0 functions from 0 modules</summary><ul></ul></details><details><summary>Source ( 5 lines)</summary><pre class="no-line-numbers" style="white-space:pre-wrap;"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">function xqp:trace($items as item()*,$label as xs:string)&#xD;
as item()*&#xD;
{  &#xD;
  if($xqp:trace) then trace($items,$label)&#xD;
}</code></pre></details></div></section><section id="namespaces"><h2>Namespaces</h2><p>The following namespaces are defined:</p><table class="data" style="float:none"><thead><tr><th>Prefix</th><th>Uri</th></tr></thead><tbody><tr><td>map</td><td><span class="badge badge-warning" title="Externally defined">http://www.w3.org/2005/xpath-functions/map</span></td></tr><tr><td>xp</td><td><span class="badge badge-warning" title="Externally defined">expkg-zone58:text.parse</span></td></tr><tr><td>xqdoc</td><td><span class="badge badge-warning" title="Externally defined">http://www.xqdoc.org/1.0</span></td></tr><tr><td>xqn</td><td><span><a href="../../modules/F000026/index.html" title="lib/xqdoc-namespace.xqm">quodatum:xqdoca.namespaces</a></span></td></tr><tr><td>xqp</td><td><span><a href="../../modules/F000022/index.html" title="lib/parser.xqm">quodatum:xqdoca.parser</a></span></td></tr><tr><td>xs</td><td><span class="badge badge-warning" title="Externally defined">http://www.w3.org/2001/XMLSchema</span></td></tr></tbody></table></section><div class="div2"><h2><a id="restxq"></a>6 RestXQ</h2><p>None</p></div><section id="source"><h2>Source Code</h2><pre style="white-space:pre-wrap;" class="line-numbers" data-src="plugins/line-numbers/index.html"><code class="language-xquery" data-prismjs-copy="Copy to clipboard">xquery version "3.1";&#xD;
(:~&#xD;
&lt;p&gt;generate and Analyse XQuery parse tree&lt;/p&gt;&#xD;
@copyright (c) 2019-2026 Quodatum Ltd&#xD;
@author Andy Bunce, Quodatum, License: Apache-2.0&#xD;
:)&#xD;
&#xD;
module namespace xqp = 'quodatum:xqdoca.parser';&#xD;
&#xD;
import module namespace xp="expkg-zone58:text.parse";&#xD;
import module namespace xqn = 'quodatum:xqdoca.namespaces' at "xqdoc-namespace.xqm";&#xD;
&#xD;
declare namespace xqdoc="http://www.xqdoc.org/1.0";&#xD;
&#xD;
&#xD;
&#xD;
(:~ xparser defaults :)&#xD;
declare variable $xqp:xparse_opts:=map{&#xD;
  "basex":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
  , "fat":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
&#xD;
};&#xD;
&#xD;
declare variable $xqp:trace as xs:boolean:=false();&#xD;
&#xD;
 &#xD;
(:~ default function namespace&#xD;
 : NOTE if parse failed will return "http://www.w3.org/2005/xpath-functions"&#xD;
 :)&#xD;
declare function xqp:default-fn-uri($xqparse as element(XQuery))&#xD;
as xs:string&#xD;
{&#xD;
  let $def-fn:= $xqparse/*//Prolog/DefaultNamespaceDecl&#xD;
  return if( empty($def-fn) ) &#xD;
         then "http://www.w3.org/2005/xpath-functions"&#xD;
         else $def-fn/URILiteral!substring(.,2,string-length(.)-2)&#xD;
};&#xD;
&#xD;
(:~ scan tree below $e for references&#xD;
 : @param $expand function to map prefixes to namespaces&#xD;
 : @return sequence of xqdoc:invoked and xqdoc:var-refences elements&#xD;
 :)&#xD;
declare  function xqp:references($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(*)*&#xD;
{&#xD;
  $e//FunctionCall!xqp:invoke-fn(.,$prefixes, $def-fn),&#xD;
  $e//ArrowExpr!xqp:invoke-arrow(.,$prefixes, $def-fn),&#xD;
  $e//VarRef!xqp:ref-variable(.,$prefixes, $def-fn) &#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(:~  build invoked nodes for function call&#xD;
 : @param $e is FunctionCall or ArrowExpr &#xD;
 :)&#xD;
declare function xqp:invoke-fn(&#xD;
                 $e as element( (:  FunctionCall :) ),&#xD;
                 $prefixes as map(*),&#xD;
                 $def-fn)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
&#xD;
let $commas:=count($e/ArgumentList/TOKEN[.=","])&#xD;
let $hasarg:=boolean($e/ArgumentList/*[not(self::TOKEN)])&#xD;
let $arity:= if($hasarg) then 1+$commas else 0&#xD;
let $arity:= if(name($e)="ArrowExpr") then $arity +1 else $arity&#xD;
let $fname:= $e/(QName|URIQualifiedName|TOKEN)/string()            &#xD;
let $_:= if(empty($fname)) then trace($e,"??????") &#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt;   &#xD;
};&#xD;
(:~  build invoked nodes for arrow expression&#xD;
 : @param $e is FunctionCall or ArrowExpr &#xD;
 :)&#xD;
declare function xqp:invoke-arrow($e as element(ArrowExpr),&#xD;
                                  $prefixes as function(*),&#xD;
                                  $def-fn as xs:string)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
for $arrow in $e/TOKEN[. = "=&amp;gt;"]&#xD;
let $fname:=$arrow/(following-sibling::QName|following-sibling::TOKEN)&#xD;
let $arglist:=$arrow/following-sibling::ArgumentList&#xD;
let $arity:=1+count($arglist/*[not(self::TOKEN)])&#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt; &#xD;
};&#xD;
&#xD;
(:~  build invoked nodes for function call&#xD;
 : @param $e is variable reference @@TODO&#xD;
 :)&#xD;
declare function xqp:ref-variable($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(xqdoc:ref-variable)&#xD;
{&#xD;
&#xD;
let $fname:= if($e/QName) then $e/QName/string() else $e/TOKEN[1]/string() &#xD;
let $qname:=xqn:qmap($fname, $prefixes, $def-fn)&#xD;
 return &lt;xqdoc:ref-variable &gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:ref-variable&gt;   &#xD;
};&#xD;
&#xD;
(:~  map of function declarations&#xD;
 : @result map where keys are Qname with # arity items are xqParse trees&#xD;
 : @param $def-fn default function namespace&#xD;
 :)&#xD;
declare function xqp:funmap($e as element(XQuery),$prefixes as map(*),$def-fn as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $items:=for $f in $e//FunctionDecl&#xD;
             let $name:=$f/*[2]&#xD;
             let $name:=if($name instance of element(QName)&#xD;
                        or $name instance of element(TOKEN)) then&#xD;
                              xqn:qmap($name,$prefixes,$def-fn)&#xD;
                        else if($name instance of element(URIQualifiedName)) then&#xD;
                                xqn:uriqname($name)&#xD;
                        else &#xD;
                             error(xs:QName("xqp:funmap"), "bad name: ", $name)&#xD;
             let $arity:=count($f/(Param|ParamList/Param))&#xD;
             let $key:=concat("Q{",$name?uri,"}",$name?name,"#",$arity)&#xD;
             return map:entry($key,$f)&#xD;
 return map:merge($items)&#xD;
};&#xD;
&#xD;
(:~ parse XQuery &#xD;
 : result is &lt;XQuery&gt; or &lt;ERROR&gt;&#xD;
 :)&#xD;
declare function xqp:parse($xq as xs:string,$platform as xs:string)&#xD;
as element(*)&#xD;
{ &#xD;
  xp:parse($xq ,$xqp:xparse_opts($platform)) &#xD;
};&#xD;
&#xD;
declare function xqp:trace($items as item()*,$label as xs:string)&#xD;
as item()*&#xD;
{  &#xD;
  if($xqp:trace) then trace($items,$label)&#xD;
};&#xD;
</code></pre></section></div></div><div class="footer"><p style="text-align:right">Generated by 
            <a href="https://github.com/Quodatum/xqdoca" target="_blank">xqDocA <span>0.9.0</span></a>
               on <span title="2025-05-17T18:35:19.705+01:00">Saturday, 17th May 2025</span></p></div><script src="../../resources/prism/1.29.0/prism.js" type="text/javascript"></script><script src="../../resources/xqdoca.js" type="text/javascript"></script></body></html>