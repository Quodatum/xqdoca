<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-05-17T18:35:19.705+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum:xqdoca.parser</xqdoc:uri><xqdoc:name>xqp</xqdoc:name><xqdoc:comment><xqdoc:description><p>generate and Analyse XQuery parse tree</p></xqdoc:description><xqdoc:author>Andy Bunce, Quodatum, License: Apache-2.0</xqdoc:author><xqdoc:custom tag="copyright">(c) 2019-2026 Quodatum Ltd</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version "3.1";&#xD;
(:~&#xD;
&lt;p&gt;generate and Analyse XQuery parse tree&lt;/p&gt;&#xD;
@copyright (c) 2019-2026 Quodatum Ltd&#xD;
@author Andy Bunce, Quodatum, License: Apache-2.0&#xD;
:)&#xD;
&#xD;
module namespace xqp = 'quodatum:xqdoca.parser';&#xD;
&#xD;
import module namespace xp="expkg-zone58:text.parse";&#xD;
import module namespace xqn = 'quodatum:xqdoca.namespaces' at "xqdoc-namespace.xqm";&#xD;
&#xD;
declare namespace xqdoc="http://www.xqdoc.org/1.0";&#xD;
&#xD;
&#xD;
&#xD;
(:~ xparser defaults :)&#xD;
declare variable $xqp:xparse_opts:=map{&#xD;
  "basex":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
  , "fat":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
&#xD;
};&#xD;
&#xD;
declare variable $xqp:trace as xs:boolean:=false();&#xD;
&#xD;
 &#xD;
(:~ default function namespace&#xD;
 : NOTE if parse failed will return "http://www.w3.org/2005/xpath-functions"&#xD;
 :)&#xD;
declare function xqp:default-fn-uri($xqparse as element(XQuery))&#xD;
as xs:string&#xD;
{&#xD;
  let $def-fn:= $xqparse/*//Prolog/DefaultNamespaceDecl&#xD;
  return if( empty($def-fn) ) &#xD;
         then "http://www.w3.org/2005/xpath-functions"&#xD;
         else $def-fn/URILiteral!substring(.,2,string-length(.)-2)&#xD;
};&#xD;
&#xD;
(:~ scan tree below $e for references&#xD;
 : @param $expand function to map prefixes to namespaces&#xD;
 : @return sequence of xqdoc:invoked and xqdoc:var-refences elements&#xD;
 :)&#xD;
declare  function xqp:references($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(*)*&#xD;
{&#xD;
  $e//FunctionCall!xqp:invoke-fn(.,$prefixes, $def-fn),&#xD;
  $e//ArrowExpr!xqp:invoke-arrow(.,$prefixes, $def-fn),&#xD;
  $e//VarRef!xqp:ref-variable(.,$prefixes, $def-fn) &#xD;
};&#xD;
&#xD;
&#xD;
&#xD;
(:~  build invoked nodes for function call&#xD;
 : @param $e is FunctionCall or ArrowExpr &#xD;
 :)&#xD;
declare function xqp:invoke-fn(&#xD;
                 $e as element( (:  FunctionCall :) ),&#xD;
                 $prefixes as map(*),&#xD;
                 $def-fn)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
&#xD;
let $commas:=count($e/ArgumentList/TOKEN[.=","])&#xD;
let $hasarg:=boolean($e/ArgumentList/*[not(self::TOKEN)])&#xD;
let $arity:= if($hasarg) then 1+$commas else 0&#xD;
let $arity:= if(name($e)="ArrowExpr") then $arity +1 else $arity&#xD;
let $fname:= $e/(QName|URIQualifiedName|TOKEN)/string()            &#xD;
let $_:= if(empty($fname)) then trace($e,"??????") &#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt;   &#xD;
};&#xD;
(:~  build invoked nodes for arrow expression&#xD;
 : @param $e is FunctionCall or ArrowExpr &#xD;
 :)&#xD;
declare function xqp:invoke-arrow($e as element(ArrowExpr),&#xD;
                                  $prefixes as function(*),&#xD;
                                  $def-fn as xs:string)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
for $arrow in $e/TOKEN[. = "=&amp;gt;"]&#xD;
let $fname:=$arrow/(following-sibling::QName|following-sibling::TOKEN)&#xD;
let $arglist:=$arrow/following-sibling::ArgumentList&#xD;
let $arity:=1+count($arglist/*[not(self::TOKEN)])&#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt; &#xD;
};&#xD;
&#xD;
(:~  build invoked nodes for function call&#xD;
 : @param $e is variable reference @@TODO&#xD;
 :)&#xD;
declare function xqp:ref-variable($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(xqdoc:ref-variable)&#xD;
{&#xD;
&#xD;
let $fname:= if($e/QName) then $e/QName/string() else $e/TOKEN[1]/string() &#xD;
let $qname:=xqn:qmap($fname, $prefixes, $def-fn)&#xD;
 return &lt;xqdoc:ref-variable &gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:ref-variable&gt;   &#xD;
};&#xD;
&#xD;
(:~  map of function declarations&#xD;
 : @result map where keys are Qname with # arity items are xqParse trees&#xD;
 : @param $def-fn default function namespace&#xD;
 :)&#xD;
declare function xqp:funmap($e as element(XQuery),$prefixes as map(*),$def-fn as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $items:=for $f in $e//FunctionDecl&#xD;
             let $name:=$f/*[2]&#xD;
             let $name:=if($name instance of element(QName)&#xD;
                        or $name instance of element(TOKEN)) then&#xD;
                              xqn:qmap($name,$prefixes,$def-fn)&#xD;
                        else if($name instance of element(URIQualifiedName)) then&#xD;
                                xqn:uriqname($name)&#xD;
                        else &#xD;
                             error(xs:QName("xqp:funmap"), "bad name: ", $name)&#xD;
             let $arity:=count($f/(Param|ParamList/Param))&#xD;
             let $key:=concat("Q{",$name?uri,"}",$name?name,"#",$arity)&#xD;
             return map:entry($key,$f)&#xD;
 return map:merge($items)&#xD;
};&#xD;
&#xD;
(:~ parse XQuery &#xD;
 : result is &lt;XQuery&gt; or &lt;ERROR&gt;&#xD;
 :)&#xD;
declare function xqp:parse($xq as xs:string,$platform as xs:string)&#xD;
as element(*)&#xD;
{ &#xD;
  xp:parse($xq ,$xqp:xparse_opts($platform)) &#xD;
};&#xD;
&#xD;
declare function xqp:trace($items as item()*,$label as xs:string)&#xD;
as item()*&#xD;
{  &#xD;
  if($xqp:trace) then trace($items,$label)&#xD;
};&#xD;
</xqdoc:body></xqdoc:module><xqdoc:imports><xqdoc:import type="library"><xqdoc:uri>expkg-zone58:text.parse</xqdoc:uri></xqdoc:import><xqdoc:import type="library"><xqdoc:uri>quodatum:xqdoca.namespaces</xqdoc:uri><xqdoc:at>xqdoc-namespace.xqm</xqdoc:at></xqdoc:import></xqdoc:imports><xqdoc:namespaces><xqdoc:namespace prefix="xqp" uri="quodatum:xqdoca.parser"/><xqdoc:namespace prefix="xp" uri="expkg-zone58:text.parse"/><xqdoc:namespace prefix="xqn" uri="quodatum:xqdoca.namespaces"/><xqdoc:namespace prefix="xqdoc" uri="http://www.xqdoc.org/1.0"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/></xqdoc:namespaces><xqdoc:variables><xqdoc:variable><xqdoc:name>xqp:xparse_opts</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
xparser defaults</xqdoc:description></xqdoc:comment><xqdoc:body>variable $xqp:xparse_opts:=map{&#xD;
  "basex":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
  , "fat":  map{ "lang": "xquery", "version": "3.1 basex",  "flatten": false() }&#xD;
&#xD;
}</xqdoc:body></xqdoc:variable><xqdoc:variable><xqdoc:name>xqp:trace</xqdoc:name><xqdoc:type>xs:boolean</xqdoc:type><xqdoc:body>variable $xqp:trace as xs:boolean:=false()</xqdoc:body></xqdoc:variable></xqdoc:variables><xqdoc:functions><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
default function namespace&#xD;
NOTE if parse failed will return "http://www.w3.org/2005/xpath-functions"&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqp:default-fn-uri</xqdoc:name><xqdoc:signature>function xqp:default-fn-uri ( $xqparse as element(XQuery) ) as xs:string { let $def-fn:= $xqparse/*//Prolog/DefaultNamespaceDecl return if( empty($def-fn) ) then "http://www.w3.org/2005/xpath-functions" else $def-fn/URILiteral!substring(.,2,string-length(.)-2) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>xqparse</xqdoc:name><xqdoc:type>element(XQuery)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:default-fn-uri($xqparse as element(XQuery))&#xD;
as xs:string&#xD;
{&#xD;
  let $def-fn:= $xqparse/*//Prolog/DefaultNamespaceDecl&#xD;
  return if( empty($def-fn) ) &#xD;
         then "http://www.w3.org/2005/xpath-functions"&#xD;
         else $def-fn/URILiteral!substring(.,2,string-length(.)-2)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
scan tree below $e for references&#xD;
</xqdoc:description><xqdoc:param>$expand function to map prefixes to namespaces</xqdoc:param><xqdoc:return>sequence of xqdoc:invoked and xqdoc:var-refences elements</xqdoc:return></xqdoc:comment><xqdoc:name>xqp:references</xqdoc:name><xqdoc:signature>function xqp:references ( $e as element(*),$prefixes as map(*), $def-fn as xs:string ) as element(*)* { $e//FunctionCall!xqp:invoke-fn(.,$prefixes, $def-fn), $e//ArrowExpr!xqp:invoke-arrow(.,$prefixes, $def-fn), $e//VarRef!xqp:ref-variable(.,$prefixes, $def-fn) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>def-fn</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">element(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:references($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(*)*&#xD;
{&#xD;
  $e//FunctionCall!xqp:invoke-fn(.,$prefixes, $def-fn),&#xD;
  $e//ArrowExpr!xqp:invoke-arrow(.,$prefixes, $def-fn),&#xD;
  $e//VarRef!xqp:ref-variable(.,$prefixes, $def-fn) &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
build invoked nodes for function call&#xD;
</xqdoc:description><xqdoc:param>$e is FunctionCall or ArrowExpr</xqdoc:param></xqdoc:comment><xqdoc:name>xqp:invoke-fn</xqdoc:name><xqdoc:signature>function xqp:invoke-fn ( $e as element( (: FunctionCall :) ), $prefixes as map(*), $def-fn ) as element(xqdoc:invoked)* { let $commas:=count($e/ArgumentList/TOKEN[.=","]) let $hasarg:=boolean($e/ArgumentList/*[not(self::TOKEN)]) let $arity:= if($hasarg) then 1+$commas else 0 let $arity:= if(name($e)="ArrowExpr") then $arity +1 else $arity let $fname:= $e/(QName|URIQualifiedName|TOKEN)/string() let $_:= if(empty($fname)) then trace($e,"??????") let $qname:=xqn:qmap($fname,$prefixes, $def-fn) return &lt;xqdoc:invoked arity="{ $arity }"&gt; &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt; &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt; &lt;/xqdoc:invoked&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element( (:  FunctionCall :) )</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>def-fn</xqdoc:name></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">element(xqdoc:invoked)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:invoke-fn(&#xD;
                 $e as element( (:  FunctionCall :) ),&#xD;
                 $prefixes as map(*),&#xD;
                 $def-fn)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
&#xD;
let $commas:=count($e/ArgumentList/TOKEN[.=","])&#xD;
let $hasarg:=boolean($e/ArgumentList/*[not(self::TOKEN)])&#xD;
let $arity:= if($hasarg) then 1+$commas else 0&#xD;
let $arity:= if(name($e)="ArrowExpr") then $arity +1 else $arity&#xD;
let $fname:= $e/(QName|URIQualifiedName|TOKEN)/string()            &#xD;
let $_:= if(empty($fname)) then trace($e,"??????") &#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt;   &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
build invoked nodes for arrow expression&#xD;
</xqdoc:description><xqdoc:param>$e is FunctionCall or ArrowExpr</xqdoc:param></xqdoc:comment><xqdoc:name>xqp:invoke-arrow</xqdoc:name><xqdoc:signature>function xqp:invoke-arrow ( $e as element(ArrowExpr), $prefixes as function(*), $def-fn as xs:string ) as element(xqdoc:invoked)* { for $arrow in $e/TOKEN[. = "=&amp;gt;"] let $fname:=$arrow/(following-sibling::QName|following-sibling::TOKEN) let $arglist:=$arrow/following-sibling::ArgumentList let $arity:=1+count($arglist/*[not(self::TOKEN)]) let $qname:=xqn:qmap($fname,$prefixes, $def-fn) return &lt;xqdoc:invoked arity="{ $arity }"&gt; &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt; &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt; &lt;/xqdoc:invoked&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(ArrowExpr)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>function(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>def-fn</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">element(xqdoc:invoked)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:invoke-arrow($e as element(ArrowExpr),&#xD;
                                  $prefixes as function(*),&#xD;
                                  $def-fn as xs:string)&#xD;
as element(xqdoc:invoked)*&#xD;
{&#xD;
for $arrow in $e/TOKEN[. = "=&amp;gt;"]&#xD;
let $fname:=$arrow/(following-sibling::QName|following-sibling::TOKEN)&#xD;
let $arglist:=$arrow/following-sibling::ArgumentList&#xD;
let $arity:=1+count($arglist/*[not(self::TOKEN)])&#xD;
let $qname:=xqn:qmap($fname,$prefixes, $def-fn)&#xD;
 return &lt;xqdoc:invoked arity="{ $arity }"&gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:invoked&gt; &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
build invoked nodes for function call&#xD;
</xqdoc:description><xqdoc:param>$e is variable reference @@TODO</xqdoc:param></xqdoc:comment><xqdoc:name>xqp:ref-variable</xqdoc:name><xqdoc:signature>function xqp:ref-variable ( $e as element(*),$prefixes as map(*), $def-fn as xs:string ) as element(xqdoc:ref-variable) { let $fname:= if($e/QName) then $e/QName/string() else $e/TOKEN[1]/string() let $qname:=xqn:qmap($fname, $prefixes, $def-fn) return &lt;xqdoc:ref-variable &gt; &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt; &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt; &lt;/xqdoc:ref-variable&gt; }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>def-fn</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(xqdoc:ref-variable)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:ref-variable($e as element(*),$prefixes as map(*), $def-fn as xs:string)&#xD;
as element(xqdoc:ref-variable)&#xD;
{&#xD;
&#xD;
let $fname:= if($e/QName) then $e/QName/string() else $e/TOKEN[1]/string() &#xD;
let $qname:=xqn:qmap($fname, $prefixes, $def-fn)&#xD;
 return &lt;xqdoc:ref-variable &gt;&#xD;
         &lt;xqdoc:uri&gt;{ $qname?uri }&lt;/xqdoc:uri&gt;&#xD;
         &lt;xqdoc:name&gt;{ $qname?name }&lt;/xqdoc:name&gt;&#xD;
        &lt;/xqdoc:ref-variable&gt;   &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
map of function declarations&#xD;
</xqdoc:description><xqdoc:param>$def-fn default function namespace</xqdoc:param><xqdoc:custom tag="result">map where keys are Qname with # arity items are xqParse trees</xqdoc:custom></xqdoc:comment><xqdoc:name>xqp:funmap</xqdoc:name><xqdoc:signature>function xqp:funmap ( $e as element(XQuery),$prefixes as map(*),$def-fn as xs:string ) as map(*) { let $items:=for $f in $e//FunctionDecl let $name:=$f/*[2] let $name:=if($name instance of element(QName) or $name instance of element(TOKEN)) then xqn:qmap($name,$prefixes,$def-fn) else if($name instance of element(URIQualifiedName)) then xqn:uriqname($name) else error(xs:QName("xqp:funmap"), "bad name: ", $name) let $arity:=count($f/(Param|ParamList/Param)) let $key:=concat("Q{",$name?uri,"}",$name?name,"#",$arity) return map:entry($key,$f) return map:merge($items) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>e</xqdoc:name><xqdoc:type>element(XQuery)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>prefixes</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>def-fn</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:funmap($e as element(XQuery),$prefixes as map(*),$def-fn as xs:string)&#xD;
as map(*)&#xD;
{&#xD;
 let $items:=for $f in $e//FunctionDecl&#xD;
             let $name:=$f/*[2]&#xD;
             let $name:=if($name instance of element(QName)&#xD;
                        or $name instance of element(TOKEN)) then&#xD;
                              xqn:qmap($name,$prefixes,$def-fn)&#xD;
                        else if($name instance of element(URIQualifiedName)) then&#xD;
                                xqn:uriqname($name)&#xD;
                        else &#xD;
                             error(xs:QName("xqp:funmap"), "bad name: ", $name)&#xD;
             let $arity:=count($f/(Param|ParamList/Param))&#xD;
             let $key:=concat("Q{",$name?uri,"}",$name?name,"#",$arity)&#xD;
             return map:entry($key,$f)&#xD;
 return map:merge($items)&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
parse XQuery&#xD;
result is &lt;XQuery&gt; or &lt;ERROR&gt;&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqp:parse</xqdoc:name><xqdoc:signature>function xqp:parse ( $xq as xs:string,$platform as xs:string ) as element(*) { xp:parse($xq ,$xqp:xparse_opts($platform)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>xq</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>platform</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>element(*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:parse($xq as xs:string,$platform as xs:string)&#xD;
as element(*)&#xD;
{ &#xD;
  xp:parse($xq ,$xqp:xparse_opts($platform)) &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:name>xqp:trace</xqdoc:name><xqdoc:signature>function xqp:trace ( $items as item()*,$label as xs:string ) as item()* { if($xqp:trace) then trace($items,$label) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>items</xqdoc:name><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>label</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">item()</xqdoc:type></xqdoc:return><xqdoc:body>function xqp:trace($items as item()*,$label as xs:string)&#xD;
as item()*&#xD;
{  &#xD;
  if($xqp:trace) then trace($items,$label)&#xD;
}</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>