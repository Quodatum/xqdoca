<XQuery><Module><VersionDecl><TOKEN>xquery</TOKEN> <TOKEN>version</TOKEN> <StringLiteral>"3.1"</StringLiteral><TOKEN>;</TOKEN></VersionDecl>
(:
 : Copyright (c) 2019 Quodatum Ltd
 :
 : Licensed under the Apache License, Version 2.0 (the "License");
 : you may not use this file except in compliance with the License.
 : You may obtain a copy of the License at
 :
 :     http://www.apache.org/licenses/LICENSE-2.0
 :
 : Unless required by applicable law or agreed to in writing, software
 : distributed under the License is distributed on an "AS IS" BASIS,
 : WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 : See the License for the specific language governing permissions and
 : limitations under the License.
 :)
 
 (:~
 : &lt;h1&gt;xqdoc-outputs.xqm&lt;/h1&gt;
 : &lt;p&gt;Load and run a set of generators&lt;/p&gt;
 :
 : @author Andy Bunce
 : @version 0.1
 :)
 

<LibraryModule><ModuleDecl><TOKEN>module</TOKEN> <TOKEN>namespace</TOKEN> <NCName>xqo</NCName> <TOKEN>=</TOKEN> <StringLiteral>'quodatum:xqdoca.outputs'</StringLiteral><TOKEN>;</TOKEN></ModuleDecl>



(:~ xqdoca annotation namespace :)
<Prolog><NamespaceDecl><TOKEN>declare</TOKEN> <TOKEN>namespace</TOKEN> <NCName>xqdoca</NCName><TOKEN>=</TOKEN><StringLiteral>"https://github.com/Quodatum/xqdoca"</StringLiteral></NamespaceDecl><TOKEN>;</TOKEN>

(:~ annotation for module derived output :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>xqo:module</QName><TOKEN>:=</TOKEN><FunctionCall><QName>QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"https://github.com/Quodatum/xqdoca"</StringLiteral><TOKEN>,</TOKEN><StringLiteral>"module"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>
(:~ annotation for global derived output :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>xqo:global</QName><TOKEN>:=</TOKEN><FunctionCall><QName>QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"https://github.com/Quodatum/xqdoca"</StringLiteral><TOKEN>,</TOKEN><StringLiteral>"global"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>
(:~ annotation used to indicate serialization options :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>xqo:ann-output</QName><TOKEN>:=</TOKEN><FunctionCall><QName>QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"https://github.com/Quodatum/xqdoca"</StringLiteral><TOKEN>,</TOKEN><StringLiteral>"output"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ defined serialization options :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <VarDecl><TOKEN>variable</TOKEN> <TOKEN>$</TOKEN><QName>xqo:outputs</QName><TOKEN>:=</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN>
                                     <MapConstructorEntry><StringLiteral>"html5"</StringLiteral><TOKEN>:</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"method"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"html"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN> <MapConstructorEntry><StringLiteral>"version"</StringLiteral><TOKEN>:</TOKEN><StringLiteral>"5.0"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN> <MapConstructorEntry><StringLiteral>"indent"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"no"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></MapConstructorEntry><TOKEN>,</TOKEN>
                                     <MapConstructorEntry><StringLiteral>"xml"</StringLiteral><TOKEN>:</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"indent"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"no"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></MapConstructorEntry><TOKEN>,</TOKEN>
                                     <MapConstructorEntry><StringLiteral>"json"</StringLiteral><TOKEN>:</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"method"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"json"</StringLiteral></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor></MapConstructorEntry>
                                   <TOKEN>}</TOKEN></MapConstructor></VarDecl></AnnotatedDecl><TOKEN>;</TOKEN>




(:~ save runtime support files to output
 : @param $target destination folder
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <Annotation><TOKEN>%</TOKEN><QName>updating</QName></Annotation>
<FunctionDecl><TOKEN>function</TOKEN> <QName>xqo:export-resources</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>target</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>                       
<TOKEN>as</TOKEN> <SequenceType><TOKEN>empty-sequence</TOKEN><TOKEN>(</TOKEN><TOKEN>)</TOKEN></SequenceType><EnclosedExpr><TOKEN>{</TOKEN>  
<FunctionCall><QName>archive:extract-to</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>target</QName></VarRef><TOKEN>,</TOKEN> <FunctionCall><QName>file:read-binary</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>'resources.zip'</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~ 
 : list xqdoca render functions found in the static context
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>xqo:renderers</QName><TOKEN>(</TOKEN><ParamList><Param><TOKEN>$</TOKEN><QName>funs</QName> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><AnyFunctionTest><TOKEN>function</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></AnyFunctionTest><TOKEN>*</TOKEN></SequenceType></TypeDeclaration></Param><TOKEN>,</TOKEN> <Param><TOKEN>$</TOKEN><QName>qname</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:QName</QName></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><AnyFunctionTest><TOKEN>function</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></AnyFunctionTest><TOKEN>*</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>f</QName> <TOKEN>in</TOKEN>  <VarRef><TOKEN>$</TOKEN><QName>funs</QName></VarRef></ForBinding></ForClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>ann</QName><TOKEN>:=</TOKEN><FunctionCall><QName>inspect:function-annotations</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>f</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause> 
  <WhereClause><TOKEN>where</TOKEN> <AndExpr><FunctionCall><QName>map:contains</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>qname</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall> <TOKEN>and</TOKEN> <FunctionCall><QName>map:contains</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:ann-output</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></AndExpr></WhereClause>
  <ReturnClause><TOKEN>return</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>f</QName></VarRef></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 :  info about a render function
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>xqo:render-map</QName><TOKEN>(</TOKEN> <Param><TOKEN>$</TOKEN><TOKEN>function</TOKEN> <TypeDeclaration><TOKEN>as</TOKEN> <SequenceType><AnyFunctionTest><TOKEN>function</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></AnyFunctionTest><TOKEN>?</TOKEN></SequenceType></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType><EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>ann</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>inspect:function-annotations</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>function</TOKEN></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>key</QName><TOKEN>:=</TOKEN><IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>map:contains</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:module</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
                <VarRef><TOKEN>$</TOKEN><QName>xqo:module</QName></VarRef>
            <TOKEN>else</TOKEN> <IfExpr><TOKEN>if</TOKEN><TOKEN>(</TOKEN><FunctionCall><QName>map:contains</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:global</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN> <TOKEN>then</TOKEN>
                <VarRef><TOKEN>$</TOKEN><QName>xqo:global</QName></VarRef>
            <TOKEN>else</TOKEN>
               <FunctionCall><QName>error</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>xs:QName</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"xqo:anno-map"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></IfExpr></IfExpr></LetBinding></LetClause>
   <ReturnClause><TOKEN>return</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN>
    <MapConstructorEntry><StringLiteral>"name"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>key</QName></VarRef><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup><Predicate><TOKEN>[</TOKEN><IntegerLiteral>1</IntegerLiteral><TOKEN>]</TOKEN></Predicate></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN>
     <MapConstructorEntry><StringLiteral>"description"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>key</QName></VarRef><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup><Predicate><TOKEN>[</TOKEN><IntegerLiteral>2</IntegerLiteral><TOKEN>]</TOKEN></Predicate></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN>
     <MapConstructorEntry><StringLiteral>"function"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><TOKEN>function</TOKEN></VarRef></MapConstructorEntry><TOKEN>,</TOKEN>
     <MapConstructorEntry><StringLiteral>"type"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>key</QName></VarRef></MapConstructorEntry><TOKEN>,</TOKEN>
     <MapConstructorEntry><StringLiteral>"uri"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:ann-output</QName></VarRef><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup><Predicate><TOKEN>[</TOKEN><IntegerLiteral>1</IntegerLiteral><TOKEN>]</TOKEN></Predicate></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN>
     <MapConstructorEntry><StringLiteral>"output"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>ann</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:ann-output</QName></VarRef><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup><Predicate><TOKEN>[</TOKEN><IntegerLiteral>2</IntegerLiteral><TOKEN>]</TOKEN></Predicate></PostfixExpr></MapConstructorEntry>
<TOKEN>}</TOKEN></MapConstructor></ReturnClause></FLWORExpr> 
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 :  render $outputs defined in $opts against state
 : @return seq of outputs generated suitable for"storing"
:)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>xqo:render</QName><TOKEN>(</TOKEN> <ParamList><Param><TOKEN>$</TOKEN><QName>model</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param><TOKEN>,</TOKEN><Param><TOKEN>$</TOKEN><QName>opts</QName> <TypeDeclaration><TOKEN>as</TOKEN> <MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType></TypeDeclaration></Param></ParamList><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><MapType><TOKEN>map</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></MapType><TOKEN>*</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>funs</QName><TOKEN>:=</TOKEN><FunctionCall><QName>xqo:load-generators</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>"generators/"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>global</QName><TOKEN>:=</TOKEN><PostfixExpr><ParenthesizedExpr><TOKEN>(</TOKEN><RelativePathExpr><FunctionCall><QName>xqo:renderers</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>funs</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:global</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>!</TOKEN><FunctionCall><QName>xqo:render-map</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr><TOKEN>)</TOKEN></ParenthesizedExpr><Predicate><TOKEN>[</TOKEN><ComparisonExpr><UnaryLookup><TOKEN>?</TOKEN><NCName>name</NCName></UnaryLookup> <TOKEN>=</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>outputs</NCName></Lookup><Lookup><TOKEN>?</TOKEN><NCName>global</NCName></Lookup></PostfixExpr></ComparisonExpr><TOKEN>]</TOKEN></Predicate></PostfixExpr></LetBinding></LetClause> 
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><TOKEN>module</TOKEN><TOKEN>:=</TOKEN><PostfixExpr><ParenthesizedExpr><TOKEN>(</TOKEN><RelativePathExpr><FunctionCall><QName>xqo:renderers</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>funs</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>xqo:module</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>!</TOKEN><FunctionCall><QName>xqo:render-map</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr><TOKEN>)</TOKEN></ParenthesizedExpr><Predicate><TOKEN>[</TOKEN><ComparisonExpr><UnaryLookup><TOKEN>?</TOKEN><NCName>name</NCName></UnaryLookup> <TOKEN>=</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>outputs</NCName></Lookup><Lookup><TOKEN>?</TOKEN><NCName>module</NCName></Lookup></PostfixExpr></ComparisonExpr><TOKEN>]</TOKEN></Predicate></PostfixExpr></LetBinding></LetClause>
  (: add found renderers info to opts :)
  <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>opts</QName><TOKEN>:=</TOKEN><FunctionCall><QName>map:merge</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><Expr><FunctionCall><QName>map:entry</QName><ArgumentList><TOKEN>(</TOKEN><StringLiteral>".renderers"</StringLiteral><TOKEN>,</TOKEN><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"global"</StringLiteral><TOKEN>:</TOKEN><VarRef><TOKEN>$</TOKEN><QName>global</QName></VarRef></MapConstructorEntry><TOKEN>,</TOKEN><MapConstructorEntry><StringLiteral>"module"</StringLiteral><TOKEN>:</TOKEN><VarRef><TOKEN>$</TOKEN><TOKEN>module</TOKEN></VarRef></MapConstructorEntry><TOKEN>}</TOKEN></MapConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <ParenthesizedExpr><TOKEN>(</TOKEN>
      <Expr><FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>render</QName> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>global</QName></VarRef></ForBinding></ForClause>
      <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>doc</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>apply</QName><ArgumentList><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>function</NCName></Lookup></PostfixExpr><TOKEN>,</TOKEN><SquareArrayConstructor><TOKEN>[</TOKEN><VarRef><TOKEN>$</TOKEN><QName>model</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>]</TOKEN></SquareArrayConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
      <ReturnClause><TOKEN>return</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"document"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef></MapConstructorEntry><TOKEN>,</TOKEN> 
                 <MapConstructorEntry><StringLiteral>"uri"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>uri</NCName></Lookup></PostfixExpr></MapConstructorEntry><TOKEN>,</TOKEN> 
                 <MapConstructorEntry><StringLiteral>"output"</StringLiteral><TOKEN>:</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>xqo:outputs</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>output</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup></PostfixExpr></MapConstructorEntry>
               <TOKEN>}</TOKEN></MapConstructor></ReturnClause></FLWORExpr><TOKEN>,</TOKEN>
               
      <FLWORExpr><ForClause><TOKEN>for</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>render</QName> <TOKEN>in</TOKEN> <VarRef><TOKEN>$</TOKEN><TOKEN>module</TOKEN></VarRef></ForBinding><TOKEN>,</TOKEN> <ForBinding><TOKEN>$</TOKEN><QName>file</QName> <PositionalVar><TOKEN>at</TOKEN> <TOKEN>$</TOKEN><QName>pos</QName></PositionalVar> <TOKEN>in</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>model</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>files</NCName></Lookup></PostfixExpr></ForBinding></ForClause>
      (: override opts for destination path :)
      <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>opts</QName><TOKEN>:=</TOKEN><FunctionCall><QName>map:merge</QName><ArgumentList><TOKEN>(</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN>
            <Expr><MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN>
              <MapConstructorEntry><StringLiteral>"root"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"../../"</StringLiteral></MapConstructorEntry><TOKEN>,</TOKEN>
              <MapConstructorEntry><StringLiteral>"resources"</StringLiteral><TOKEN>:</TOKEN> <StringLiteral>"../../resources/"</StringLiteral></MapConstructorEntry>
            <TOKEN>}</TOKEN></MapConstructor><TOKEN>,</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef></Expr><TOKEN>)</TOKEN></ParenthesizedExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
      <LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>doc</QName><TOKEN>:=</TOKEN> <FunctionCall><QName>apply</QName><ArgumentList><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>function</NCName></Lookup></PostfixExpr><TOKEN>,</TOKEN><SquareArrayConstructor><TOKEN>[</TOKEN><VarRef><TOKEN>$</TOKEN><QName>file</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>opts</QName></VarRef><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>model</QName></VarRef><TOKEN>]</TOKEN></SquareArrayConstructor><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>       
      <ReturnClause><TOKEN>return</TOKEN> <MapConstructor><TOKEN>map</TOKEN><TOKEN>{</TOKEN><MapConstructorEntry><StringLiteral>"document"</StringLiteral><TOKEN>:</TOKEN> <VarRef><TOKEN>$</TOKEN><QName>doc</QName></VarRef></MapConstructorEntry><TOKEN>,</TOKEN> 
                 <MapConstructorEntry><StringLiteral>"uri"</StringLiteral><TOKEN>:</TOKEN> <FunctionCall><QName>concat</QName><ArgumentList><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>file</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>href</NCName></Lookup></PostfixExpr><TOKEN>,</TOKEN><StringLiteral>"/"</StringLiteral><TOKEN>,</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>uri</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ArgumentList></FunctionCall></MapConstructorEntry><TOKEN>,</TOKEN>  
                 <MapConstructorEntry><StringLiteral>"output"</StringLiteral><TOKEN>:</TOKEN> <PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>xqo:outputs</QName></VarRef><Lookup><TOKEN>?</TOKEN><ParenthesizedExpr><TOKEN>(</TOKEN><PostfixExpr><VarRef><TOKEN>$</TOKEN><QName>render</QName></VarRef><Lookup><TOKEN>?</TOKEN><NCName>output</NCName></Lookup></PostfixExpr><TOKEN>)</TOKEN></ParenthesizedExpr></Lookup></PostfixExpr></MapConstructorEntry>
                <TOKEN>}</TOKEN></MapConstructor></ReturnClause></FLWORExpr></Expr>
              <TOKEN>)</TOKEN></ParenthesizedExpr></ReturnClause></FLWORExpr>                                      
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN>

(:~
 : dynamically load functions from *.xqm modules from generators directory into static context
 :)
<AnnotatedDecl><TOKEN>declare</TOKEN> <FunctionDecl><TOKEN>function</TOKEN> <QName>xqo:load-generators</QName><TOKEN>(</TOKEN><Param><TOKEN>$</TOKEN><QName>path</QName> <TypeDeclaration><TOKEN>as</TOKEN> <QName>xs:string</QName></TypeDeclaration></Param><TOKEN>)</TOKEN>
<TOKEN>as</TOKEN> <SequenceType><AnyFunctionTest><TOKEN>function</TOKEN><TOKEN>(</TOKEN><TOKEN>*</TOKEN><TOKEN>)</TOKEN></AnyFunctionTest><TOKEN>*</TOKEN></SequenceType>
<EnclosedExpr><TOKEN>{</TOKEN>
  <FLWORExpr><LetClause><TOKEN>let</TOKEN> <LetBinding><TOKEN>$</TOKEN><QName>base</QName><TOKEN>:=</TOKEN><FunctionCall><QName>resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>path</QName></VarRef><TOKEN>,</TOKEN><FunctionCall><QName>static-base-uri</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></LetBinding></LetClause>
  <ReturnClause><TOKEN>return</TOKEN> <RelativePathExpr><FunctionCall><QName>file:list</QName><ArgumentList><TOKEN>(</TOKEN><VarRef><TOKEN>$</TOKEN><QName>base</QName></VarRef><TOKEN>,</TOKEN><FunctionCall><QName>true</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>,</TOKEN><StringLiteral>"*.xqm"</StringLiteral><TOKEN>)</TOKEN></ArgumentList></FunctionCall>
       <TOKEN>!</TOKEN> <FunctionCall><QName>inspect:functions</QName><ArgumentList><TOKEN>(</TOKEN><FunctionCall><QName>resolve-uri</QName><ArgumentList><TOKEN>(</TOKEN><TOKEN>.</TOKEN><TOKEN>,</TOKEN><VarRef><TOKEN>$</TOKEN><QName>base</QName></VarRef><TOKEN>)</TOKEN></ArgumentList></FunctionCall><TOKEN>)</TOKEN></ArgumentList></FunctionCall></RelativePathExpr></ReturnClause></FLWORExpr>
<TOKEN>}</TOKEN></EnclosedExpr></FunctionDecl></AnnotatedDecl><TOKEN>;</TOKEN></Prolog></LibraryModule></Module><EOF/></XQuery>