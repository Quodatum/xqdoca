<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-05-17T18:35:19.705+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum:tools:commandline</xqdoc:uri><xqdoc:name>cmd</xqdoc:name><xqdoc:comment><xqdoc:description><p>command line tool support.</p></xqdoc:description><xqdoc:version>0.3</xqdoc:version><xqdoc:custom tag="copyright">Copyright (c) 2019-2025 Quodatum Ltd</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version "3.1";&#xD;
(:~&#xD;
 &lt;p&gt;command line tool support.&lt;/p&gt;&#xD;
 @copyright Copyright (c) 2019-2025 Quodatum Ltd&#xD;
 @version 0.3&#xD;
:)&#xD;
module namespace cmd = 'quodatum:tools:commandline';&#xD;
import module namespace semver = "http://exist-db.org/xquery/semver" at "semver.xqm";&#xD;
declare namespace pkg="http://expath.org/ns/pkg";&#xD;
&#xD;
declare variable $cmd:repo-list:= xs:anyURI("https://raw.githubusercontent.com/expkg-zone58/catalog/main/repositories.xml");&#xD;
&#xD;
(:~  simple command line parse splits on space unless in quotes :)&#xD;
declare function cmd:parse-args($str as xs:string)&#xD;
as xs:string*{&#xD;
let $r:= fold-left(&#xD;
   string-to-codepoints($str)! codepoints-to-string(.),&#xD;
   map{"state": "","tokens":(),"current":""},&#xD;
   cmd:parse2#2) &#xD;
return ($r?tokens, if(string-length($r?current) ne 0) then $r?current else ())&#xD;
};&#xD;
&#xD;
(:~&#xD;
state machine apply input $char to $state&#xD;
@return state  &#xD;
:)&#xD;
declare %private function cmd:parse2($state as map(*),$char as xs:string)&#xD;
as map(*){&#xD;
 let $new:=switch ($char)&#xD;
 case '"'&#xD;
 case "'" return map:entry("state",if($state?state eq $char) then "" else $char)               &#xD;
                   &#xD;
 case ' ' return if($state?state eq "")&#xD;
                  then if(string-length($state?current) ne 0)&#xD;
                       then  map {  "tokens": ($state?tokens,$state?current), "current": ""}&#xD;
                       else ()&#xD;
                 else map:entry("current", $state?current || $char)&#xD;
                 &#xD;
  default return  map:entry("current", $state?current || $char)&#xD;
  return map:merge(($new,$state))       &#xD;
};&#xD;
&#xD;
(:~ raise error if deps missing&#xD;
@error  pkg:version Basex version running now is not supported&#xD;
@error  pkg:missing package missing&#xD;
@return version :)&#xD;
declare function cmd:check-dependencies($pkg as element(pkg:package))&#xD;
as empty-sequence(){&#xD;
  let $basex:=$pkg/pkg:dependency[@processor="http://basex.org/"]&#xD;
  let $basex-active:= db:system()/generalinformation/version&#xD;
  return &#xD;
         if(cmd:semver-fails( $basex-active , $basex))&#xD;
         then error(xs:QName("pkg:version"),``[BaseX version `{ $basex-active }`  not be supported]``)&#xD;
         else (&#xD;
                  for $p in $pkg/pkg:dependency[@name]&#xD;
                  return if(cmd:not-installed($p/@name,$p)) &#xD;
                        then error(xs:QName("pkg:missing"),"No suitable version found in repo for: " || $p/@name) &#xD;
                        else ()&#xD;
               )&#xD;
};&#xD;
&#xD;
(:~ check if semver $version is NOT allowed by $spec &#xD;
@param spec element with some of @version, @semver-min, @semver-max&#xD;
@return true if fails&#xD;
:)&#xD;
declare function cmd:semver-fails($version as xs:string,$spec as element(*))&#xD;
as xs:boolean{&#xD;
   if($spec/@version)&#xD;
   then semver:ne($version,$spec/@version,true())&#xD;
   else &#xD;
      let $min:=if($spec/@semver-min)&#xD;
                  then semver:lt($version,$spec/@semver-min,true())&#xD;
                  else false()&#xD;
&#xD;
      let $max:=if($spec/@semver-max)&#xD;
                  then semver:gt($version,$spec/@semver-max,true())&#xD;
                  else false()                             &#xD;
      return $min or $max                     &#xD;
};&#xD;
&#xD;
(:~ no suitable version of package installed :)&#xD;
declare function cmd:not-installed($package as xs:string,$spec as element(*))&#xD;
as xs:boolean{&#xD;
   every $v in repo:list()[@name=$package] &#xD;
   satisfies cmd:semver-fails($v/@version,$spec)           &#xD;
};&#xD;
&#xD;
(:~ url to install package $name where version is compatable with spec&#xD;
@param $store-url url listing packages&#xD;
:)&#xD;
declare function cmd:package-url($name as xs:string,$spec as element(*),$store-url as xs:anyURI)&#xD;
as xs:string{&#xD;
     let $hits:=doc($store-url)/repositories/repository&#xD;
                 /package[@name=$name]/releases/release[not(cmd:semver-fails(@version,$spec))]&#xD;
     return if(empty($hits))&#xD;
            then  error(xs:QName("pkg:version"),"no source for :" || $name)&#xD;
            else resolve-uri($hits[1],base-uri($hits[1]))&#xD;
};&#xD;
&#xD;
(:~ install all dependencies from packages :)&#xD;
declare function cmd:install-dependencies($pkg as element(pkg:package))&#xD;
as empty-sequence(){&#xD;
    for  $p in $pkg/pkg:dependency[@name]&#xD;
    where cmd:not-installed($p/@name,$p)&#xD;
    let $src:=cmd:package-url($p/@name, $p, $cmd:repo-list)&#xD;
    return repo:install($src=&gt;trace("Installing: "))&#xD;
};&#xD;
</xqdoc:body></xqdoc:module><xqdoc:imports><xqdoc:import type="library"><xqdoc:uri>http://exist-db.org/xquery/semver</xqdoc:uri><xqdoc:at>semver.xqm</xqdoc:at></xqdoc:import></xqdoc:imports><xqdoc:namespaces><xqdoc:namespace prefix="cmd" uri="quodatum:tools:commandline"/><xqdoc:namespace prefix="semver" uri="http://exist-db.org/xquery/semver"/><xqdoc:namespace prefix="pkg" uri="http://expath.org/ns/pkg"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/><xqdoc:namespace prefix="db" uri="http://basex.org/modules/db"/><xqdoc:namespace prefix="repo" uri="http://basex.org/modules/repo"/></xqdoc:namespaces><xqdoc:variables><xqdoc:variable><xqdoc:name>cmd:repo-list</xqdoc:name><xqdoc:body>variable $cmd:repo-list:= xs:anyURI("https://raw.githubusercontent.com/expkg-zone58/catalog/main/repositories.xml")</xqdoc:body></xqdoc:variable></xqdoc:variables><xqdoc:functions><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
simple command line parse splits on space unless in quotes</xqdoc:description></xqdoc:comment><xqdoc:name>cmd:parse-args</xqdoc:name><xqdoc:signature>function cmd:parse-args ( $str as xs:string ) as xs:string* { let $r:= fold-left( string-to-codepoints($str)! codepoints-to-string(.), map{"state": "","tokens":(),"current":""}, cmd:parse2#2) return ($r?tokens, if(string-length($r?current) ne 0) then $r?current else ()) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>str</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:parse-args($str as xs:string)&#xD;
as xs:string*{&#xD;
let $r:= fold-left(&#xD;
   string-to-codepoints($str)! codepoints-to-string(.),&#xD;
   map{"state": "","tokens":(),"current":""},&#xD;
   cmd:parse2#2) &#xD;
return ($r?tokens, if(string-length($r?current) ne 0) then $r?current else ())&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
state machine apply input $char to $state&#xD;
</xqdoc:description><xqdoc:return>state</xqdoc:return></xqdoc:comment><xqdoc:name>cmd:parse2</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="private"/></xqdoc:annotations><xqdoc:signature>function cmd:parse2 ( $state as map(*),$char as xs:string ) as map(*) { let $new:=switch ($char) case '"' case "'" return map:entry("state",if($state?state eq $char) then "" else $char) case ' ' return if($state?state eq "") then if(string-length($state?current) ne 0) then map { "tokens": ($state?tokens,$state?current), "current": ""} else () else map:entry("current", $state?current || $char) default return map:entry("current", $state?current || $char) return map:merge(($new,$state)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>state</xqdoc:name><xqdoc:type>map(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>char</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map(*)</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:parse2($state as map(*),$char as xs:string)&#xD;
as map(*){&#xD;
 let $new:=switch ($char)&#xD;
 case '"'&#xD;
 case "'" return map:entry("state",if($state?state eq $char) then "" else $char)               &#xD;
                   &#xD;
 case ' ' return if($state?state eq "")&#xD;
                  then if(string-length($state?current) ne 0)&#xD;
                       then  map {  "tokens": ($state?tokens,$state?current), "current": ""}&#xD;
                       else ()&#xD;
                 else map:entry("current", $state?current || $char)&#xD;
                 &#xD;
  default return  map:entry("current", $state?current || $char)&#xD;
  return map:merge(($new,$state))       &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
raise error if deps missing</xqdoc:description><xqdoc:return>version</xqdoc:return><xqdoc:error>pkg:version Basex version running now is not supported</xqdoc:error><xqdoc:error>pkg:missing package missing</xqdoc:error></xqdoc:comment><xqdoc:name>cmd:check-dependencies</xqdoc:name><xqdoc:signature>function cmd:check-dependencies ( $pkg as element(pkg:package) ) as empty-sequence() { let $basex:=$pkg/pkg:dependency[@processor="http://basex.org/"] let $basex-active:= db:system()/generalinformation/version return if(cmd:semver-fails( $basex-active , $basex)) then error(xs:QName("pkg:version"),``[BaseX version `{ $basex-active }` not be supported]``) else ( for $p in $pkg/pkg:dependency[@name] return if(cmd:not-installed($p/@name,$p)) then error(xs:QName("pkg:missing"),"No suitable version found in repo for: " || $p/@name) else () ) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pkg</xqdoc:name><xqdoc:type>element(pkg:package)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:check-dependencies($pkg as element(pkg:package))&#xD;
as empty-sequence(){&#xD;
  let $basex:=$pkg/pkg:dependency[@processor="http://basex.org/"]&#xD;
  let $basex-active:= db:system()/generalinformation/version&#xD;
  return &#xD;
         if(cmd:semver-fails( $basex-active , $basex))&#xD;
         then error(xs:QName("pkg:version"),``[BaseX version `{ $basex-active }`  not be supported]``)&#xD;
         else (&#xD;
                  for $p in $pkg/pkg:dependency[@name]&#xD;
                  return if(cmd:not-installed($p/@name,$p)) &#xD;
                        then error(xs:QName("pkg:missing"),"No suitable version found in repo for: " || $p/@name) &#xD;
                        else ()&#xD;
               )&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
check if semver $version is NOT allowed by $spec&#xD;
</xqdoc:description><xqdoc:param>spec element with some of @version, @semver-min, @semver-max</xqdoc:param><xqdoc:return>true if fails</xqdoc:return></xqdoc:comment><xqdoc:name>cmd:semver-fails</xqdoc:name><xqdoc:signature>function cmd:semver-fails ( $version as xs:string,$spec as element(*) ) as xs:boolean { if($spec/@version) then semver:ne($version,$spec/@version,true()) else let $min:=if($spec/@semver-min) then semver:lt($version,$spec/@semver-min,true()) else false() let $max:=if($spec/@semver-max) then semver:gt($version,$spec/@semver-max,true()) else false() return $min or $max }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>version</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>spec</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:semver-fails($version as xs:string,$spec as element(*))&#xD;
as xs:boolean{&#xD;
   if($spec/@version)&#xD;
   then semver:ne($version,$spec/@version,true())&#xD;
   else &#xD;
      let $min:=if($spec/@semver-min)&#xD;
                  then semver:lt($version,$spec/@semver-min,true())&#xD;
                  else false()&#xD;
&#xD;
      let $max:=if($spec/@semver-max)&#xD;
                  then semver:gt($version,$spec/@semver-max,true())&#xD;
                  else false()                             &#xD;
      return $min or $max                     &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
no suitable version of package installed</xqdoc:description></xqdoc:comment><xqdoc:name>cmd:not-installed</xqdoc:name><xqdoc:signature>function cmd:not-installed ( $package as xs:string,$spec as element(*) ) as xs:boolean { every $v in repo:list()[@name=$package] satisfies cmd:semver-fails($v/@version,$spec) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>package</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>spec</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:boolean</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:not-installed($package as xs:string,$spec as element(*))&#xD;
as xs:boolean{&#xD;
   every $v in repo:list()[@name=$package] &#xD;
   satisfies cmd:semver-fails($v/@version,$spec)           &#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="3"><xqdoc:comment><xqdoc:description>&#xD;
url to install package $name where version is compatable with spec&#xD;
</xqdoc:description><xqdoc:param>$store-url url listing packages</xqdoc:param></xqdoc:comment><xqdoc:name>cmd:package-url</xqdoc:name><xqdoc:signature>function cmd:package-url ( $name as xs:string,$spec as element(*),$store-url as xs:anyURI ) as xs:string { let $hits:=doc($store-url)/repositories/repository /package[@name=$name]/releases/release[not(cmd:semver-fails(@version,$spec))] return if(empty($hits)) then error(xs:QName("pkg:version"),"no source for :" || $name) else resolve-uri($hits[1],base-uri($hits[1])) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>spec</xqdoc:name><xqdoc:type>element(*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>store-url</xqdoc:name><xqdoc:type>xs:anyURI</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:package-url($name as xs:string,$spec as element(*),$store-url as xs:anyURI)&#xD;
as xs:string{&#xD;
     let $hits:=doc($store-url)/repositories/repository&#xD;
                 /package[@name=$name]/releases/release[not(cmd:semver-fails(@version,$spec))]&#xD;
     return if(empty($hits))&#xD;
            then  error(xs:QName("pkg:version"),"no source for :" || $name)&#xD;
            else resolve-uri($hits[1],base-uri($hits[1]))&#xD;
}</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
install all dependencies from packages</xqdoc:description></xqdoc:comment><xqdoc:name>cmd:install-dependencies</xqdoc:name><xqdoc:signature>function cmd:install-dependencies ( $pkg as element(pkg:package) ) as empty-sequence() { for $p in $pkg/pkg:dependency[@name] where cmd:not-installed($p/@name,$p) let $src:=cmd:package-url($p/@name, $p, $cmd:repo-list) return repo:install($src=&gt;trace("Installing: ")) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>pkg</xqdoc:name><xqdoc:type>element(pkg:package)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:body>function cmd:install-dependencies($pkg as element(pkg:package))&#xD;
as empty-sequence(){&#xD;
    for  $p in $pkg/pkg:dependency[@name]&#xD;
    where cmd:not-installed($p/@name,$p)&#xD;
    let $src:=cmd:package-url($p/@name, $p, $cmd:repo-list)&#xD;
    return repo:install($src=&gt;trace("Installing: "))&#xD;
}</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>