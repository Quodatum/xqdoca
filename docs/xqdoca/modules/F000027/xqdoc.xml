<xqdoc:xqdoc xmlns:xqdoc="http://www.xqdoc.org/1.0"><xqdoc:control><xqdoc:date>2025-05-17T18:35:19.705+01:00</xqdoc:date><xqdoc:version>1.1</xqdoc:version></xqdoc:control><xqdoc:module type="library"><xqdoc:uri>quodatum:xqdoca.outputs</xqdoc:uri><xqdoc:name>xqo</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
o/p  utils&#xD;
</xqdoc:description><xqdoc:author>Andy Bunce, Quodatum, License: Apache-2.0</xqdoc:author><xqdoc:custom tag="Copyright">(c) 2019-2026 Quodatum Ltd</xqdoc:custom></xqdoc:comment><xqdoc:body>xquery version "3.1";&#xD;
&#xD;
&#xD;
(:~&#xD;
 : o/p  utils&#xD;
 : @Copyright (c) 2019-2026 Quodatum Ltd&#xD;
 : @author Andy Bunce, Quodatum, License: Apache-2.0&#xD;
 ::)&#xD;
&#xD;
&#xD;
module namespace xqo = 'quodatum:xqdoca.outputs';&#xD;
&#xD;
&#xD;
(:~ xqdoca annotation namespace :)&#xD;
declare namespace xqdoca = "https://github.com/Quodatum/xqdoca";&#xD;
&#xD;
(:~ annotation for module derived output :)&#xD;
&#xD;
&#xD;
declare variable $xqo:module := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                      "module");&#xD;
&#xD;
(:~ annotation for global derived output :)&#xD;
declare variable $xqo:global := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                      "global");&#xD;
&#xD;
(:~ annotation used to indicate serialization options :)&#xD;
declare variable $xqo:ann-output := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                          "output");&#xD;
&#xD;
(:~ defined serialization options :)&#xD;
declare variable $xqo:outputs := map { &#xD;
    "html5" : map { "method" : "html", "version" : "5.0", "indent" : "no" }, &#xD;
    "xhtml" : map { "method" : "xhtml",   "version" : "1.0",  'html-version': '5.0', "indent" : "no" }, &#xD;
    "xml" : map { "indent" : "no" },&#xD;
    "json" : map { "method" : "json" }, &#xD;
    "text" : map { "method" : "text" } };&#xD;
&#xD;
(:~ full path to resources sources :)&#xD;
declare variable $xqo:resources as xs:anyURI := resolve-uri('../etc/resources');&#xD;
&#xD;
&#xD;
&#xD;
(:~ save runtime support files to output&#xD;
 : @param $target destination folder&#xD;
 ::)&#xD;
declare %updating function xqo:export-resources($target as xs:string)&#xD;
as empty-sequence () { let $res := $target || "resources"&#xD;
let $_ := trace($target, "target:")&#xD;
let $_ := trace($xqo:resources, "src:")&#xD;
return&#xD;
    (if (file:exists($res)) then&#xD;
        file:delete($res, true())&#xD;
    else&#xD;
        ()&#xD;
    ,&#xD;
    file:copy($xqo:resources, $target)) };&#xD;
&#xD;
(:~&#xD;
 : list xqdoca render functions found in the static context&#xD;
 ::)&#xD;
declare function xqo:renderers($funs as function (*)*, $qname as xs:QName)&#xD;
as function (*)* { for $f in $funs&#xD;
let $ann := inspect:function-annotations($f)&#xD;
where map:contains($ann, $qname) and map:contains($ann, $xqo:ann-output)&#xD;
return $f };&#xD;
&#xD;
(:~&#xD;
 : info about a render function&#xD;
 ::)&#xD;
declare function xqo:render-map($function as function (*)?)&#xD;
as map (*) { let $ann := inspect:function-annotations($function)&#xD;
let $key :=&#xD;
    if (map:contains($ann, $xqo:module)) then&#xD;
        $xqo:module&#xD;
    else if (map:contains($ann, $xqo:global)) then&#xD;
        $xqo:global&#xD;
    else&#xD;
        error(xs:QName("xqo:anno-map"))&#xD;
return&#xD;
    map { "name" : $ann? ($key)[1], "description" : $ann? ($key)[2], "function"&#xD;
        : $function, "type" : $key, "uri" : $ann? ($xqo:ann-output)[1], "output"&#xD;
        : $ann? ($xqo:ann-output)[2] } };&#xD;
&#xD;
(:~&#xD;
 :  render $outputs defined in $opts against state&#xD;
 : @return seq of outputs generated suitable for"storing"&#xD;
 ::)&#xD;
declare function xqo:render($model as map (*), $opts as map (*))&#xD;
as map (*)* { let $funs := xqo:load-generators("../generators/")&#xD;
let $wanted := xqo:tokens($opts? outputs? global)&#xD;
let $global :=&#xD;
    (xqo:renderers($funs, $xqo:global) ! xqo:render-map(.))[? name = $wanted]&#xD;
let $modules := xqo:tokens($opts? outputs? module)&#xD;
let $module :=&#xD;
    (xqo:renderers($funs, $xqo:module) ! xqo:render-map(.))[? name = $modules]&#xD;
(: add found renderers info to opts :) let $opts :=&#xD;
    map:merge((map:entry(".renderers",&#xD;
                         map { "global" : $global, "module" : $module }),&#xD;
              $opts))&#xD;
return&#xD;
    (for $render in $global&#xD;
    let $doc := apply($render? function,[$model, $opts])&#xD;
    return&#xD;
        map { "document" : $doc, "uri" : $render? uri, "output" : $xqo:outputs?&#xD;
            ($render? output) },&#xD;
    for $render in $module, $file at $pos in $model? files&#xD;
    (: override opts for destination path :) let $opts :=&#xD;
        map:merge((map { "root" : "../../", "resources" : "../../resources/" },&#xD;
                  $opts))&#xD;
    let $doc := apply($render? function,[$file, $model, $opts])&#xD;
    return&#xD;
        map { "document" : $doc, "uri" : concat($file? href, "/", $render? uri),&#xD;
            "output" : $xqo:outputs? ($render? output) }) };&#xD;
&#xD;
(:~&#xD;
 : dynamically load functions from *.xqm modules from generators directory into&#xD;
 : static context&#xD;
 ::)&#xD;
declare function xqo:load-generators($path as xs:string)&#xD;
as function (*)* { let $base := resolve-uri($path, static-base-uri())&#xD;
return&#xD;
    file:list($base, true(), "*.xqm") ! translate(., "\", "/") !&#xD;
        inspect:functions(resolve-uri(., $base)) };&#xD;
&#xD;
(:~&#xD;
 : parse tokens&#xD;
 ::)&#xD;
declare function xqo:tokens($s as xs:string)&#xD;
as xs:string* { $s =&gt; normalize-space() =&gt; tokenize("[\s,]+") };&#xD;
&#xD;
(:~&#xD;
 : zip all&#xD;
 : @param $target destination folder using file protocoleg file:///&#xD;
 ::)&#xD;
declare %updating function xqo:zip($target as xs:string, $name as xs:string)&#xD;
as empty-sequence () { &#xD;
    let $files :=file:list($target =&gt; trace("Creating zip: "), true()) &#xD;
                 [not(ends-with(.,file:dir-separator()))]&#xD;
    let $zip :=&#xD;
    archive:create($files,&#xD;
                   $files ! file:read-binary($target || translate(., "\", "/")))&#xD;
return file:write-binary($target || $name || ".zip", $zip) };</xqdoc:body></xqdoc:module><xqdoc:namespaces><xqdoc:namespace prefix="xqo" uri="quodatum:xqdoca.outputs"/><xqdoc:namespace prefix="xqdoca" uri="https://github.com/Quodatum/xqdoca"/><xqdoc:namespace prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/><xqdoc:namespace prefix="file" uri="http://expath.org/ns/file"/><xqdoc:namespace prefix="inspect" uri="http://basex.org/modules/inspect"/><xqdoc:namespace prefix="map" uri="http://www.w3.org/2005/xpath-functions/map"/><xqdoc:namespace prefix="archive" uri="http://basex.org/modules/archive"/></xqdoc:namespaces><xqdoc:variables><xqdoc:variable><xqdoc:name>xqo:module</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
annotation for module derived output</xqdoc:description></xqdoc:comment><xqdoc:body>variable $xqo:module := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                      "module")</xqdoc:body></xqdoc:variable><xqdoc:variable><xqdoc:name>xqo:global</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
annotation for global derived output</xqdoc:description></xqdoc:comment><xqdoc:body>variable $xqo:global := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                      "global")</xqdoc:body></xqdoc:variable><xqdoc:variable><xqdoc:name>xqo:ann-output</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
annotation used to indicate serialization options</xqdoc:description></xqdoc:comment><xqdoc:body>variable $xqo:ann-output := QName("https://github.com/Quodatum/xqdoca",&#xD;
                                          "output")</xqdoc:body></xqdoc:variable><xqdoc:variable><xqdoc:name>xqo:outputs</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
defined serialization options</xqdoc:description></xqdoc:comment><xqdoc:body>variable $xqo:outputs := map { &#xD;
    "html5" : map { "method" : "html", "version" : "5.0", "indent" : "no" }, &#xD;
    "xhtml" : map { "method" : "xhtml",   "version" : "1.0",  'html-version': '5.0', "indent" : "no" }, &#xD;
    "xml" : map { "indent" : "no" },&#xD;
    "json" : map { "method" : "json" }, &#xD;
    "text" : map { "method" : "text" } }</xqdoc:body></xqdoc:variable><xqdoc:variable><xqdoc:name>xqo:resources</xqdoc:name><xqdoc:comment><xqdoc:description>&#xD;
full path to resources sources</xqdoc:description></xqdoc:comment><xqdoc:type>xs:anyURI</xqdoc:type><xqdoc:body>variable $xqo:resources as xs:anyURI := resolve-uri('../etc/resources')</xqdoc:body></xqdoc:variable></xqdoc:variables><xqdoc:functions><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
save runtime support files to output&#xD;
</xqdoc:description><xqdoc:param>$target destination folder</xqdoc:param></xqdoc:comment><xqdoc:name>xqo:export-resources</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="updating"/></xqdoc:annotations><xqdoc:signature>function xqo:export-resources ( $target as xs:string ) as empty-sequence () { let $res := $target || "resources" let $_ := trace($target, "target:") let $_ := trace($xqo:resources, "src:") return (if (file:exists($res)) then file:delete($res, true()) else () , file:copy($xqo:resources, $target)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>target</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:export-resources($target as xs:string)&#xD;
as empty-sequence () { let $res := $target || "resources"&#xD;
let $_ := trace($target, "target:")&#xD;
let $_ := trace($xqo:resources, "src:")&#xD;
return&#xD;
    (if (file:exists($res)) then&#xD;
        file:delete($res, true())&#xD;
    else&#xD;
        ()&#xD;
    ,&#xD;
    file:copy($xqo:resources, $target)) }</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
list xqdoca render functions found in the static context&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqo:renderers</xqdoc:name><xqdoc:signature>function xqo:renderers ( $funs as function (*)*, $qname as xs:QName ) as function (*)* { for $f in $funs let $ann := inspect:function-annotations($f) where map:contains($ann, $qname) and map:contains($ann, $xqo:ann-output) return $f }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>funs</xqdoc:name><xqdoc:type occurrence="*">function (*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>qname</xqdoc:name><xqdoc:type>xs:QName</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">function (*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:renderers($funs as function (*)*, $qname as xs:QName)&#xD;
as function (*)* { for $f in $funs&#xD;
let $ann := inspect:function-annotations($f)&#xD;
where map:contains($ann, $qname) and map:contains($ann, $xqo:ann-output)&#xD;
return $f }</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
info about a render function&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqo:render-map</xqdoc:name><xqdoc:signature>function xqo:render-map ( $function as function (*)? ) as map (*) { let $ann := inspect:function-annotations($function) let $key := if (map:contains($ann, $xqo:module)) then $xqo:module else if (map:contains($ann, $xqo:global)) then $xqo:global else error(xs:QName("xqo:anno-map")) return map { "name" : $ann? ($key)[1], "description" : $ann? ($key)[2], "function" : $function, "type" : $key, "uri" : $ann? ($xqo:ann-output)[1], "output" : $ann? ($xqo:ann-output)[2] } }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>function</xqdoc:name><xqdoc:type occurrence="?">function (*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>map (*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:render-map($function as function (*)?)&#xD;
as map (*) { let $ann := inspect:function-annotations($function)&#xD;
let $key :=&#xD;
    if (map:contains($ann, $xqo:module)) then&#xD;
        $xqo:module&#xD;
    else if (map:contains($ann, $xqo:global)) then&#xD;
        $xqo:global&#xD;
    else&#xD;
        error(xs:QName("xqo:anno-map"))&#xD;
return&#xD;
    map { "name" : $ann? ($key)[1], "description" : $ann? ($key)[2], "function"&#xD;
        : $function, "type" : $key, "uri" : $ann? ($xqo:ann-output)[1], "output"&#xD;
        : $ann? ($xqo:ann-output)[2] } }</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
render $outputs defined in $opts against state&#xD;
</xqdoc:description><xqdoc:return>seq of outputs generated suitable for"storing"</xqdoc:return></xqdoc:comment><xqdoc:name>xqo:render</xqdoc:name><xqdoc:signature>function xqo:render ( $model as map (*), $opts as map (*) ) as map (*)* { let $funs := xqo:load-generators("../generators/") let $wanted := xqo:tokens($opts? outputs? global) let $global := (xqo:renderers($funs, $xqo:global) ! xqo:render-map(.))[? name = $wanted] let $modules := xqo:tokens($opts? outputs? module) let $module := (xqo:renderers($funs, $xqo:module) ! xqo:render-map(.))[? name = $modules] (: add found renderers info to opts :) let $opts := map:merge((map:entry(".renderers", map { "global" : $global, "module" : $module }), $opts)) return (for $render in $global let $doc := apply($render? function,[$model, $opts]) return map { "document" : $doc, "uri" : $render? uri, "output" : $xqo:outputs? ($render? output) }, for $render in $module, $file at $pos in $model? files (: override opts for destination path :) let $opts := map:merge((map { "root" : "../../", "resources" : "../../resources/" }, $opts)) let $doc := apply($render? function,[$file, $model, $opts]) return map { "document" : $doc, "uri" : concat($file? href, "/", $render? uri), "output" : $xqo:outputs? ($render? output) }) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>model</xqdoc:name><xqdoc:type>map (*)</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>opts</xqdoc:name><xqdoc:type>map (*)</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">map (*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:render($model as map (*), $opts as map (*))&#xD;
as map (*)* { let $funs := xqo:load-generators("../generators/")&#xD;
let $wanted := xqo:tokens($opts? outputs? global)&#xD;
let $global :=&#xD;
    (xqo:renderers($funs, $xqo:global) ! xqo:render-map(.))[? name = $wanted]&#xD;
let $modules := xqo:tokens($opts? outputs? module)&#xD;
let $module :=&#xD;
    (xqo:renderers($funs, $xqo:module) ! xqo:render-map(.))[? name = $modules]&#xD;
(: add found renderers info to opts :) let $opts :=&#xD;
    map:merge((map:entry(".renderers",&#xD;
                         map { "global" : $global, "module" : $module }),&#xD;
              $opts))&#xD;
return&#xD;
    (for $render in $global&#xD;
    let $doc := apply($render? function,[$model, $opts])&#xD;
    return&#xD;
        map { "document" : $doc, "uri" : $render? uri, "output" : $xqo:outputs?&#xD;
            ($render? output) },&#xD;
    for $render in $module, $file at $pos in $model? files&#xD;
    (: override opts for destination path :) let $opts :=&#xD;
        map:merge((map { "root" : "../../", "resources" : "../../resources/" },&#xD;
                  $opts))&#xD;
    let $doc := apply($render? function,[$file, $model, $opts])&#xD;
    return&#xD;
        map { "document" : $doc, "uri" : concat($file? href, "/", $render? uri),&#xD;
            "output" : $xqo:outputs? ($render? output) }) }</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
dynamically load functions from *.xqm modules from generators directory into&#xD;
static context&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqo:load-generators</xqdoc:name><xqdoc:signature>function xqo:load-generators ( $path as xs:string ) as function (*)* { let $base := resolve-uri($path, static-base-uri()) return file:list($base, true(), "*.xqm") ! translate(., "\", "/") ! inspect:functions(resolve-uri(., $base)) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>path</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">function (*)</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:load-generators($path as xs:string)&#xD;
as function (*)* { let $base := resolve-uri($path, static-base-uri())&#xD;
return&#xD;
    file:list($base, true(), "*.xqm") ! translate(., "\", "/") !&#xD;
        inspect:functions(resolve-uri(., $base)) }</xqdoc:body></xqdoc:function><xqdoc:function arity="1"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
parse tokens&#xD;
</xqdoc:description></xqdoc:comment><xqdoc:name>xqo:tokens</xqdoc:name><xqdoc:signature>function xqo:tokens ( $s as xs:string ) as xs:string* { $s =&gt; normalize-space() =&gt; tokenize("[\s,]+") }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>s</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type occurrence="*">xs:string</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:tokens($s as xs:string)&#xD;
as xs:string* { $s =&gt; normalize-space() =&gt; tokenize("[\s,]+") }</xqdoc:body></xqdoc:function><xqdoc:function arity="2"><xqdoc:comment><xqdoc:description>&#xD;
&#xD;
zip all&#xD;
</xqdoc:description><xqdoc:param>$target destination folder using file protocoleg file:///</xqdoc:param></xqdoc:comment><xqdoc:name>xqo:zip</xqdoc:name><xqdoc:annotations><xqdoc:annotation name="updating"/></xqdoc:annotations><xqdoc:signature>function xqo:zip ( $target as xs:string, $name as xs:string ) as empty-sequence () { let $files :=file:list($target =&gt; trace("Creating zip: "), true()) [not(ends-with(.,file:dir-separator()))] let $zip := archive:create($files, $files ! file:read-binary($target || translate(., "\", "/"))) return file:write-binary($target || $name || ".zip", $zip) }</xqdoc:signature><xqdoc:parameters><xqdoc:parameter><xqdoc:name>target</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter><xqdoc:parameter><xqdoc:name>name</xqdoc:name><xqdoc:type>xs:string</xqdoc:type></xqdoc:parameter></xqdoc:parameters><xqdoc:return><xqdoc:type>empty-sequence</xqdoc:type></xqdoc:return><xqdoc:body>function xqo:zip($target as xs:string, $name as xs:string)&#xD;
as empty-sequence () { &#xD;
    let $files :=file:list($target =&gt; trace("Creating zip: "), true()) &#xD;
                 [not(ends-with(.,file:dir-separator()))]&#xD;
    let $zip :=&#xD;
    archive:create($files,&#xD;
                   $files ! file:read-binary($target || translate(., "\", "/")))&#xD;
return file:write-binary($target || $name || ".zip", $zip) }</xqdoc:body></xqdoc:function></xqdoc:functions></xqdoc:xqdoc>