{"version":3,"file":"svg.panzoom.min.js","sources":["../src/svg.panzoom.js"],"sourcesContent":["import { Svg, on, off, extend, Matrix, Box } from '@svgdotjs/svg.js'\n\nconst normalizeEvent = ev =>\n  ev.touches || [{ clientX: ev.clientX, clientY: ev.clientY }]\n\nextend(Svg, {\n  panZoom (options) {\n    this.off('.panZoom')\n\n    // when called with false, disable panZoom\n    if (options === false) return this\n\n    options = options ?? {}\n    const zoomFactor = options.zoomFactor ?? 2\n    const zoomMin = options.zoomMin ?? Number.MIN_VALUE\n    const zoomMax = options.zoomMax ?? Number.MAX_VALUE\n    const doWheelZoom = options.wheelZoom ?? true\n    const doPinchZoom = options.pinchZoom ?? true\n    const doPanning = options.panning ?? true\n    const panButton = options.panButton ?? 0\n    const oneFingerPan = options.oneFingerPan ?? false\n    const margins = options.margins ?? false\n    const wheelZoomDeltaModeLinePixels = options.wheelZoomDeltaModeLinePixels ?? 17\n    const wheelZoomDeltaModeScreenPixels = options.wheelZoomDeltaModeScreenPixels ?? 53\n\n    let lastP\n    let lastTouches\n    let zoomInProgress = false\n\n    const viewbox = this.viewbox()\n\n    const restrictToMargins = box => {\n      if (!margins) return box\n      const { top, left, bottom, right } = margins\n\n      const { width, height } = this.attr(['width', 'height'])\n      const preserveAspectRatio = this.node.preserveAspectRatio.baseVal\n\n      // The current viewport (exactly what is shown on the screen, what we ultimately want to restrict)\n      // is not always exactly the same as current viewbox. They are different when the viewbox aspectRatio and the svg aspectRatio\n      // are different and preserveAspectRatio is not \"none\". These offsets represent the difference in user coordinates\n      // between the side of the viewbox and the side of the viewport.\n      let viewportLeftOffset = 0\n      let viewportRightOffset = 0\n      let viewportTopOffset = 0\n      let viewportBottomOffset = 0\n\n      // preserveAspectRatio none has no offsets\n      if (preserveAspectRatio.align !== preserveAspectRatio.SVG_PRESERVEASPECTRATIO_NONE) {\n        const svgAspectRatio = width / height\n        const viewboxAspectRatio = viewbox.width / viewbox.height\n        // when aspectRatios are the same, there are no offsets\n        if (viewboxAspectRatio !== svgAspectRatio) {\n          // aspectRatio unknown is like meet because that's the default\n          const isMeet = preserveAspectRatio.meetOrSlice !== preserveAspectRatio.SVG_MEETORSLICE_SLICE\n          const changedAxis = svgAspectRatio > viewboxAspectRatio ? 'width' : 'height'\n          const isWidth = changedAxis === 'width'\n          const changeHorizontal = (isMeet && isWidth) || (!isMeet && !isWidth)\n          const ratio = changeHorizontal\n            ? svgAspectRatio / viewboxAspectRatio\n            : viewboxAspectRatio / svgAspectRatio\n\n          const offset = box[changedAxis] - box[changedAxis] * ratio\n          if (changeHorizontal) {\n            if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX) {\n              viewportLeftOffset = offset / 2\n              viewportRightOffset = -offset / 2\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX) {\n              viewportRightOffset = -offset\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) {\n              viewportLeftOffset = offset\n            }\n          } else {\n            if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMID ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMID) {\n              viewportTopOffset = offset / 2\n              viewportBottomOffset = -offset / 2\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMIN ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMIN) {\n              viewportBottomOffset = -offset\n            } else if (\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMINYMAX ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMIDYMAX ||\n              preserveAspectRatio.align === preserveAspectRatio.SVG_PRESERVEASPECTRATIO_XMAXYMAX) {\n              viewportTopOffset = offset\n            }\n          }\n\n        }\n      }\n\n      // when box.x == leftLimit, the image is panned to the left,\n      // i.e the current box is to the right of the initial viewbox,\n      // and only the right part of the initial image is visible, i.e.\n      // the right side of the initial viewbox minus left margin (viewbox.x+viewbox.width-left)\n      // is aligned with the left side of the viewport (box.x + viewportLeftOffset):\n      // viewbox.width + viewbox.x - left = box.x + viewportLeftOffset\n      // viewbox.width + viewbox.x - left - viewportLeftOffset = box.x (= leftLimit)\n      const leftLimit = viewbox.width + viewbox.x - left - viewportLeftOffset\n      // when box.x == rightLimit, the image is panned to the right,\n      // i.e the current box is to the left of the initial viewbox\n      // and only the left part of the initial image is visible, i.e\n      // the left side of the initial viewbox plus right margin (viewbox.x + right)\n      // is aligned with the right side of the viewport (box.x + box.width + viewportRightOffset)\n      // viewbox.x + right = box.x + box.width + viewportRightOffset\n      // viewbox.x + right - box.width - viewportRightOffset = box.x (= rightLimit)\n      const rightLimit = viewbox.x + right - box.width - viewportRightOffset\n      // same with top and bottom\n      const topLimit = viewbox.height + viewbox.y - top - viewportTopOffset\n      const bottomLimit = viewbox.y + bottom - box.height - viewportBottomOffset\n\n      box.x = Math.min(leftLimit, Math.max(rightLimit, box.x)) // enforce rightLimit <= box.x <= leftLimit\n      box.y = Math.min(topLimit, Math.max(bottomLimit, box.y)) // enforce bottomLimit <= box.y <= topLimit\n      return box\n    }\n\n    const wheelZoom = function (ev) {\n      ev.preventDefault()\n\n      // When wheeling on a mouse,\n      // - chrome by default uses deltaY = 53, deltaMode = 0 (pixel)\n      // - firefox by default uses deltaY = 3, deltaMode = 1 (line)\n      // - chrome and firefox on windows after configuring \"One screen at a time\"\n      //   use deltaY = 1, deltaMode = 2 (screen)\n      //\n      // Note that when when wheeling on a touchpad, deltaY depends on how fast\n      // you swipe, but the deltaMode is still different between the browsers.\n      //\n      // Normalize everything so that zooming speed is approximately the same in all cases\n      let normalizedPixelDeltaY\n      switch (ev.deltaMode) {\n      case 1:\n        normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeLinePixels\n        break\n      case 2:\n        normalizedPixelDeltaY = ev.deltaY * wheelZoomDeltaModeScreenPixels\n        break\n      default:\n        // 0 (already pixels) or new mode (avoid crashing)\n        normalizedPixelDeltaY = ev.deltaY\n        break\n      }\n\n      let lvl = Math.pow(1 + zoomFactor, (-1 * normalizedPixelDeltaY) / 100) * this.zoom()\n      const p = this.point(ev.clientX, ev.clientY)\n\n      if (lvl > zoomMax) {\n        lvl = zoomMax\n      }\n\n      if (lvl < zoomMin) {\n        lvl = zoomMin\n      }\n\n      if (this.dispatch('zoom', { level: lvl, focus: p }).defaultPrevented) {\n        return this\n      }\n\n      this.zoom(lvl, p)\n\n      if (margins) {\n        const box = restrictToMargins(this.viewbox())\n        this.viewbox(box)\n      }\n    }\n\n    const pinchZoomStart = function (ev) {\n      lastTouches = normalizeEvent(ev)\n\n      // Start panning in case only one touch is found\n      if (lastTouches.length < 2) {\n        if (doPanning && oneFingerPan) {\n          panStart.call(this, ev)\n        }\n        return\n      }\n\n      // Stop panning for more than one touch\n      if (doPanning && oneFingerPan) {\n        panStop.call(this, ev)\n      }\n\n      // We call it so late, so the user is still able to scroll / reload the page via gesture\n      // In case oneFingerPan is not active\n      ev.preventDefault()\n\n      if (this.dispatch('pinchZoomStart', { event: ev }).defaultPrevented) {\n        return\n      }\n\n      this.off('touchstart.panZoom', pinchZoomStart)\n\n      zoomInProgress = true\n      on(document, 'touchmove.panZoom', pinchZoom, this, { passive: false })\n      on(document, 'touchend.panZoom', pinchZoomStop, this, { passive: false })\n    }\n\n    const pinchZoomStop = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n      if (currentTouches.length > 1) {\n        return\n      }\n\n      zoomInProgress = false\n\n      this.dispatch('pinchZoomEnd', { event: ev })\n\n      off(document, 'touchmove.panZoom', pinchZoom)\n      off(document, 'touchend.panZoom', pinchZoomStop)\n      this.on('touchstart.panZoom', pinchZoomStart)\n\n      if (currentTouches.length && doPanning && oneFingerPan) {\n        panStart.call(this, ev)\n      }\n    }\n\n    const pinchZoom = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n      const zoom = this.zoom()\n\n      // Distance Formula\n      const lastDelta = Math.sqrt(\n        Math.pow(lastTouches[0].clientX - lastTouches[1].clientX, 2) +\n          Math.pow(lastTouches[0].clientY - lastTouches[1].clientY, 2)\n      )\n\n      const currentDelta = Math.sqrt(\n        Math.pow(currentTouches[0].clientX - currentTouches[1].clientX, 2) +\n          Math.pow(currentTouches[0].clientY - currentTouches[1].clientY, 2)\n      )\n\n      let zoomAmount = lastDelta / currentDelta\n\n      if (\n        (zoom < zoomMin && zoomAmount > 1) ||\n        (zoom > zoomMax && zoomAmount < 1)\n      ) {\n        zoomAmount = 1\n      }\n\n      const currentFocus = {\n        x:\n          currentTouches[0].clientX +\n          0.5 * (currentTouches[1].clientX - currentTouches[0].clientX),\n        y:\n          currentTouches[0].clientY +\n          0.5 * (currentTouches[1].clientY - currentTouches[0].clientY)\n      }\n\n      const lastFocus = {\n        x:\n          lastTouches[0].clientX +\n          0.5 * (lastTouches[1].clientX - lastTouches[0].clientX),\n        y:\n          lastTouches[0].clientY +\n          0.5 * (lastTouches[1].clientY - lastTouches[0].clientY)\n      }\n\n      const p = this.point(currentFocus.x, currentFocus.y)\n      const focusP = this.point(\n        2 * currentFocus.x - lastFocus.x,\n        2 * currentFocus.y - lastFocus.y\n      )\n      const box = new Box(this.viewbox()).transform(\n        new Matrix()\n          .translate(-focusP.x, -focusP.y)\n          .scale(zoomAmount, 0, 0)\n          .translate(p.x, p.y)\n      )\n\n      restrictToMargins(box)\n      this.viewbox(box)\n\n      lastTouches = currentTouches\n\n      this.dispatch('zoom', { box: box, focus: focusP })\n    }\n\n    const panStart = function (ev) {\n      const isMouse = ev.type.indexOf('mouse') > -1\n\n      // In case panStart is called with touch, ev.button is undefined\n      if (isMouse && ev.button !== panButton && ev.which !== panButton + 1) {\n        return\n      }\n\n      ev.preventDefault()\n\n      this.off('mousedown.panZoom', panStart)\n\n      lastTouches = normalizeEvent(ev)\n\n      if (zoomInProgress) return\n\n      this.dispatch('panStart', { event: ev })\n\n      lastP = { x: lastTouches[0].clientX, y: lastTouches[0].clientY }\n\n      on(document, 'touchmove.panZoom mousemove.panZoom', panning, this, {\n        passive: false\n      })\n\n      on(document, 'touchend.panZoom mouseup.panZoom', panStop, this, {\n        passive: false\n      })\n    }\n\n    const panStop = function (ev) {\n      ev.preventDefault()\n\n      off(document, 'touchmove.panZoom mousemove.panZoom', panning)\n      off(document, 'touchend.panZoom mouseup.panZoom', panStop)\n      this.on('mousedown.panZoom', panStart)\n\n      this.dispatch('panEnd', { event: ev })\n    }\n\n    const panning = function (ev) {\n      ev.preventDefault()\n\n      const currentTouches = normalizeEvent(ev)\n\n      const currentP = {\n        x: currentTouches[0].clientX,\n        y: currentTouches[0].clientY\n      }\n\n      const p1 = this.point(currentP.x, currentP.y)\n\n      const p2 = this.point(lastP.x, lastP.y)\n\n      const deltaP = [p2.x - p1.x, p2.y - p1.y]\n\n      if (!deltaP[0] && !deltaP[1]) {\n        return\n      }\n\n      const box = new Box(this.viewbox()).transform(\n        new Matrix().translate(deltaP[0], deltaP[1])\n      )\n\n      lastP = currentP\n\n      restrictToMargins(box)\n\n      if (this.dispatch('panning', { box, event: ev }).defaultPrevented) {\n        return\n      }\n\n      this.viewbox(box)\n    }\n\n    if (doWheelZoom) {\n      this.on('wheel.panZoom', wheelZoom, this, { passive: false })\n    }\n\n    if (doPinchZoom) {\n      this.on('touchstart.panZoom', pinchZoomStart, this, { passive: false })\n    }\n\n    if (doPanning) {\n      this.on('mousedown.panZoom', panStart, this, { passive: false })\n    }\n\n    return this\n  }\n})\n"],"names":["normalizeEvent","ev","touches","clientX","clientY","Svg","panZoom","options","off","this","restrictToMargins","box","margins","top","left","bottom","right","_this","attr","width","height","preserveAspectRatio","node","baseVal","viewportLeftOffset","viewportRightOffset","viewportTopOffset","viewportBottomOffset","align","SVG_PRESERVEASPECTRATIO_NONE","svgAspectRatio","viewboxAspectRatio","viewbox","isMeet","meetOrSlice","SVG_MEETORSLICE_SLICE","changedAxis","isWidth","changeHorizontal","ratio","offset","SVG_PRESERVEASPECTRATIO_XMIDYMIN","SVG_PRESERVEASPECTRATIO_XMIDYMID","SVG_PRESERVEASPECTRATIO_XMIDYMAX","SVG_PRESERVEASPECTRATIO_XMINYMIN","SVG_PRESERVEASPECTRATIO_XMINYMID","SVG_PRESERVEASPECTRATIO_XMINYMAX","SVG_PRESERVEASPECTRATIO_XMAXYMIN","SVG_PRESERVEASPECTRATIO_XMAXYMID","SVG_PRESERVEASPECTRATIO_XMAXYMAX","leftLimit","x","rightLimit","topLimit","y","bottomLimit","Math","min","max","pinchZoomStart","lastTouches","length","doPanning","oneFingerPan","panStart","call","panStop","preventDefault","dispatch","event","defaultPrevented","zoomInProgress","on","document","pinchZoom","passive","pinchZoomStop","lastP","zoomFactor","zoomMin","Number","MIN_VALUE","zoomMax","MAX_VALUE","doWheelZoom","wheelZoom","doPinchZoom","panning","panButton","wheelZoomDeltaModeLinePixels","wheelZoomDeltaModeScreenPixels","currentTouches","zoom","zoomAmount","sqrt","pow","currentFocus","lastFocus","p","point","focusP","Box","transform","Matrix","translate","scale","focus","type","indexOf","button","which","currentP","p1","p2","deltaP","normalizedPixelDeltaY","deltaMode","deltaY","lvl","level"],"mappings":"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"}